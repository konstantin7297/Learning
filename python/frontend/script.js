'use strict'; // Включает строгий режим, который добавляет новые правила и заставляет писать код более корректно.

let myReg = /\d/g; // Регулярное выражение: '/параметры/g'.
let myLet = 'Первое слово с маленькой буквы'; // Объявляет переменную, которую можно изменить.
var myVar = 'Второе слово с большой буквы'; // Объявляет переменную, которую можно изменить, но имеет более широкую область видимости.
const MY_CONST = 'Const пишут и так большими через подчеркивания'; // Объявляет константу, которую нельзя изменить после объявления.

const myJoin = `${myLet} + ${myVar} = ${myLet + myVar}`; // Шаблонные строки позволяют встраивать выражения и переменные в строку. Еще они много страничные.
let myBigInt = 1_000n; // BigInt важен для работы с 14+ значными цифрами для избежания ошибок в операциях. Нижний прочерк - просто декор, улучшающий читаемость.

let myType = typeof myLet; // Показывает тип значения переменной. Примеры: (123 + 321) = 444(number), (123 + '456') = 123456(string), ('16' / '8') = 2(number).
myBigInt--; // Декремент, уменьшает значение на 1. Можно и '--myBigInt', тогда сперва отнимется значение, а потом изменится переменная. Поддерживает и другие знаки.
let myBool1 = 2 === '2'; // Сравнивает типы данных включая перевод JS в другие типы данные (строку в число и т.д.). == - легкий режим, где 2 == '2' - true.
let myBool2 = !1 // Определяет true или false, а ! - инвертирует его на противоположное значение. В данном случае будет 'false'.
let myBool3 = 2 === 3 ? 'true' : 'false'; // Урезанный условный оператор, если условие верное, то будет 'true', иначе будет 'false'.
let myOp = 1 ?? 2 || 3 && 4; // ?? - 'Или'(не учитывает bool: 0, []...), || - 'Или'(учитывает bool), && - И(выполняется раньше, чем 'или').

let myObj = { // Объект или же классический словарь. Обращаться к ключам можно так: myObject.key или myObject['key'] по классике.
    one: 1, // Для удаления элемента пишется: delete myObject.key или myObject['key'], в общем как обычно. Добавляются данные тоже как обычно.
    myLet, // Так добавляются переменные по своему же имени, т.е. 'myLet: myLet'.
    [myLet]: myLet, // Так добавляются переменные, если нужно значение сделать ключом. Т.е. 'value: value' в данном примере.
    newObj: {'a': 1}, // Обращаться к опциональным параметрам без ошибки можно так: '$(myObj?.newObj?.a ?? 'Не указано')' - выводит 'а' если она есть без доп. ошибок. Лучший синтаксис.
} // При распаковке можно указать: 'const {one, newObj, ...last} = myObj', тогда будут получены именные параметры и коллекция с оставшимися.
let myData = new Map() // Тот же объект, но позволяет хранить сразу и 1 и '1' в ключах. Но управляется методами: .set(k, v), .get(k), .has(k), .delete(k) и т.д.
let mySet = new Set() // Сохраняет только уникальные элементы. Если подать список [1, 2, 2], то вернет: [1, 2].
let myObjCopy1 = Object.assign({}, myObj) // Копирует объект с новой ссылкой. Но не рекурсивно, внутренние объекты так не копируются. Поддерживает складывание.
let myObjCopy2 = {...myObj} // Копирует объект с новой ссылкой. Просто другой вариант синтаксиса. Они оба так же поддерживают и складывание таким образом списка объектов.
let {one, newObj} = myObj // Так можно распаковать объект в отдельные одноименные переменные. Переименовать переменные: 'one: first'. По-умолчанию: 'one = "нет"'.
let toJson = JSON.stringify(myObj) // Преобразует JavaScript -> Json код.
let toObj = JSON.parse(toJson) // Преобразует Json -> JavaScript код.

const myPrompt = prompt('Описание', 'default')  // Добавляет всплывающее окно с полем ввода, 2 параметр - значение по-умолчанию. Если закрыть - будет 'null'.
const myConfirm = confirm('Ok?') // Добавляет всплывающее окно с кнопками: 'ok', 'cancel'. Отдает 'true' или 'false'.
alert('message')  // Показывает сообщение во всплывающем окне. Так же он приостанавливает код, пока не будет закрыто окно уведомления.
setTimeout(myFunc, 200) // Запуск функции после загрузки страницы. Значение указывается в миллисекундах. 3+ параметры - аргументы для функции. Объект: 'clearTimeout(...)' - выкл.
setInterval(myFunc, 200) // Периодический запуск функции. Значение в миллисекундах. 3+ параметры - аргументы для функции. Объект 'clearInterval(...)' - выключает его.
console.log('message:', 111) // Пишет в консоль, // - однострочный коммент, /* */ - многострочный коммент.

if (1) { // Так делается условный оператор: 'if (условия) {действия} else if (условия) {действия} else {действия}', при написании в одну строку '{}' не нужны.
    console.log(1)
} else if (2) {
    console.log(2)
} else {
    console.log(3)
}

switch (1) { // Аналог условного оператора, проверяет условие на различные значения. Если сделать (true) - можно проверять условие на список значений, типа 'case age > 18:'.
    case 1: { // Проверяет, что условие (1) будет == 1, если верно - выполнит свой код.
        console.log(1)
        break // Если убрать break - выполнит ВСЕ блоки независимо от условий.
    }
    default: { // Если ни одно условие не подошло, выполнится этот блок.
        console.log('default')
    }
}

while (myBigInt > 0) { // Классический while. Можно еще так: do {инструкция} while (условие).
    myBigInt--  // Отнимает у переменной 1 единицу.
}

for (let i = 0; i < 3; i++) { // 1 параметр - переменная для счета. 2 параметр - проверяется на каждой итерации. 3 параметр - выполняется на каждой итерации.
    console.log(i) // Обычный for, значений из условий можно опустить, но ставить ';' нужно. Переменные из цикла не доступны за его пределами (область видимости), но global доступен.
} // Для итерации по массиву: 'for (let key in(или of) myObject) {...}', числовые ключи JS сортирует перед итерацией, так что ключи (1, 2...) лучше не делать.

function myFunc(value = 'hello') { // Классическая функция, вызов: myFunc('hello'), пустой параметр можно указать как 'undefined' при вызове.
    return value // Если не получать переменные в функции, то все переданные параметры будут лежать в переменной 'arguments' в виде массива. Но зависит от реализации функции.
} // Неявно отдает 'undefined', если нет 'return'. Объявить функцию можно и так: 'const myResult = () => {...}', но не будет 'arguments' (типа лямбда функция).

const calculate = { // Слово 'this' - ссылается на родительский объект. Содержит в себе всего его атрибуты и методы.
    read() { // В случае лямбда функций - ссылается на более высокий уровень объекта (т.е. пропускает лямбду).
        this.a = Number(prompt('Введите А: ', '0')) // Устанавливает объекту 'calculate' значение 'a'.
        this.b = Number(prompt('Введите Б: ', '0')) // Устанавливает объекту 'calculate' значение 'b'.
        console.log(this.a + this.b) // Пишет сумму полученных от пользователя значений.
    } // При вызове calculate.read() - запросит у пользователя 2 значения и сложит их.
}

class Student { // Реализация класса в JS. Наследование: 'class Child extends Parent {...}'. Создание класса: 'new Student(...)'.
    static country = 'Россия' // Статический параметр. К таким параметрам можно обратиться без инициализации класса.
    #city = null // Приватный параметр. К нему нельзя обратиться за пределами класса. Для методов используется '_' в начале.

    constructor(name, age) { // Метод запускается при инициализации класса. Аналог '__init__'.
        this.name = name
        this.age = age
    }
    set city(value) { // Метод для установки приватного параметра. Классический сеттер.
        this.#city = value
    } // Объект 'super.city(...)' позволяет унаследовать функционал метода. Классический super.
    get city() { // Метод для получения приватного параметра. Классический геттер.
        return this.#city
    }
}

try { // Обработка ошибок в JS.
    // Потенциально проблемный код, который может получить ошибку.
    if (!1) { // Так можно вручную проверять какие-то условия и выкидывать ошибки. !1 - вернет 'false'.
        throw new Error('Самостоятельно вызванная ошибка. Аналог "raise".')
    }
} catch (error) { // Переменная 'error' с информацией об ошибке.
    // Обработка возникшей ошибки.
} finally {
    // Блок, который будет вызван в любом случае и точно последним.
}

const asyncFunc = async (val1, onSuccess) => { // Слово 'async' говорит, что функция работает в отложенном режиме, 'await' говорит, что нужно дождаться конца работы функции.
    return new Promise((fulfill, reject) => { // Асинхронная функция, Функция fulfill - успешного выполнения, reject - безуспешного.
        setTimeout(() => { // Отложенная функция, работает через 3000мс после загрузки страницы.
            if (Math.random() > 0.5) { // Условие рандомно выкидывает число в диапазоне 0 - 1.
                fulfill('Победа!') // При выполнении условия запускаем функцию успешного выполнения.
            } else {
                reject('Поражение!') // При провале условия запускаем функцию провального выполнения.
            }
        }, 3000)
    }) // promise.then((successData) => {}).catch((errorData) => {}).finally(() => {}) - обработка promise состояний.
}
