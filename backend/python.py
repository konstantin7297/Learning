class Information:
    """ Класс, в котором хранится общая ознакомительная информация. Сложных вещей тут нет. """
    another_info = {
        "ORM": "Эта абстракция позволяет работать с объектами БД как с объектами используемого языка программирования, не отвлекаясь на их преобразование в язык SQL",  # noqa
        "Сериализация и Десериализация": "процесс перевода структуры данных в байты и обратно",  # noqa
        "json.dump()": "Сериализует объект из файла. json.dumps() - то же самое, но для строки. Для отправки.",  # noqa
        "json.load()": "Десериализует объект из файла. json.loads() - то же самое, но для строки. Для загрузки.",  # noqa
        "ACID": "Атомарность, Консистентность, изолированность, стойкость",  # noqa
        "Аутентификация": "Процесс подтверждения личности пользователя. Например: ввод логина и пароля.",  # noqa
        "Авторизация": "Проверка прав пользователя на какие-либо действия. Например: проверка доступа к ресурсу.",  # noqa
        "Идентификация": "Определение объекта пользователя. Например: запрос его профиля из БД.",  # noqa
        "header": "Дополнительные сведения о запросе или ответе, такие как тип контента, кодировка, длина контента, информация о клиенте и сервере, а также cookies.",  # noqa
        "cookie": "Небольшие текстовые файлы, которые хранятся в браузере и отправляются обратно на сервер при каждом последующем запросе.",  # noqa
        "payload": "Основное содержимое HTTP-запроса или ответа. Это может быть HTML-страница, изображение, файл или другая информация, которую сервер отправляет клиенту или клиент серверу.",  # noqa
        "Интернационализация": "Процесс обработки кода для добавления локализаций. То есть добавление шаблонов, которые будут переводиться на разные языки.",  # noqa
        "Локализация": "Процесс перевода шаблонов в коде для добавления поддержки разных языков.",  # noqa
    }  # Информация и основные определения. # noqa

    python_exceptions = {
        "BaseException": "базовое исключение, от которого берут начало все остальные.",
        "   SystemExit": "исключение, порождаемое функцией sys.exit при выходе из программы.",
        "   KeyboardInterrupt": "порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).",
        "   GeneratorExit": "порождается при вызове метода close объекта generator.",
        "   Exception": "обыкновенные, с которыми можно работать.",
        "       StopIteration": "порождается встроенной функцией next, если в итераторе больше нет элементов.",
        "       ArithmeticError": "арифметическая ошибка.",
        "           FloatingPointError": "порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.",
        "           OverflowError": "возникает, когда результат арифметической операции слишком велик для представления.",
        "           ZeroDivisionError": "деление на ноль.",
        "       AssertionError": "выражение в функции assert ложно.",
        "       AttributeError": "объект не имеет данного атрибута (значения или метода).",
        "       BufferError": "операция, связанная с буфером, не может быть выполнена.",
        "       EOFError": "функция наткнулась на конец файла и не смогла прочитать то, что хотела.",
        "       ImportError": "не удалось импортирование модуля или его атрибута.",
        "       LookupError": "некорректный индекс или ключ.",
        "           IndexError": "индекс не входит в диапазон элементов",
        "           KeyError": "несуществующий ключ (в словаре, множестве или другом объекте).",
        "       MemoryError": "недостаточно памяти.",
        "       NameError": "не найдено переменной с таким именем.",
        "           UnboundLocalError": "сделана ссылка на локальную переменную в функции, но переменная не определена ранее.",
        "       OSError": "ошибка, связанная с системой.",
        "           BlockingIOError": "NONE",
        "           ChildProcessError": "неудача при операции с дочерним процессом.",
        "           ConnectionError": "базовый класс для исключений, связанных с подключениями.",
        "               BrokenPipeError": "NONE",
        "               ConnectionAbortedError": "NONE",
        "               ConnectionRefusedError": "NONE",
        "               ConnectionResetError": "NONE",
        "           FileExistsError": "попытка создания файла или директории, которая уже существует.",
        "           FileNotFoundError": "файл или директория не существует.",
        "           InterruptedError": "системный вызов прерван входящим сигналом.",
        "           IsADirectoryError": "ожидался файл, но это директория.",
        "           NotADirectoryError": "ожидалась директория, но это файл.",
        "           PermissionError": "не хватает прав доступа.",
        "           ProcessLookupError": "указанного процесса не существует.",
        "           TimeoutError": "закончилось время ожидания.",
        "       ReferenceError": "попытка доступа к атрибуту со слабой ссылкой.",
        "       RuntimeError": "возникает, когда исключение не попадает ни под одну из других категорий.",
        "       NotImplementedError": "возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.",
        "       SyntaxError": "синтаксическая ошибка.",
        "           IndentationError": "неправильные отступы.",
        "               TabError": "смешивание в отступах табуляции и пробелов.",
        "       SystemError": "внутренняя ошибка.",
        "       TypeError": "операция применена к объекту несоответствующего типа.",
        "       ValueError": "функция получает аргумент правильного типа, но некорректного значения.",
        "       UnicodeError": "ошибка, связанная с кодированием / раскодированием unicode в строках.",  # noqa
        "           UnicodeEncodeError": "исключение, связанное с кодированием unicode.",
        "           UnicodeDecodeError": "исключение, связанное с декодированием unicode.",
        "           UnicodeTranslateError": "исключение, связанное с переводом unicode.",
        "       Warning": "предупреждение."
    }  # Список основных исключений python и их значения. # noqa

    ports = {
        "22": "Для удалённого доступа по SSH.",
        "80": "Порт по-умолчанию для обращения к Web-серверу по протоколу HTTP.",
        "443": "Порт по-умолчанию для обращения к Web-серверу по протоколу HTTPS.",
        "5000": "Порт по-умолчанию для обращения к Backend-приложению.",
        "5432": "Порт по-умолчанию для обращения к Базе Данных Postgres.",
        "6379": "Порт по-умолчанию для обращения к Celery",
    }  # Основные используемые в программировании порты. # noqa

    console_cmd = {
        "adduser имя": "добавляет пользователя на облачный сервер, после чего устанавливает ему пароль и некоторую информацию(которую можно пропустить)",  # noqa
        "sudo groupadd docker": "создает группу пользователей, которая имеет какие либо права, docker - программа",  # noqa
        "usermod -aG sudo имя": "дает пользователю соответствующие права(дает роль 'sudo' указанному пользователю и следовательно возможность юзать sudo)",  # noqa
        "newgrp docker": "позволяет перезагрузить группу 'docker', если она изменилась. Если не работает, можно перезагрузить ОС.",  # noqa
        "sudo chown -R 1000:1000 ./folder или sudo chmod 666 ./folder": "выдать полные или частичные права на папку.",  # noqa
        "chmod 700 .ssh": "выдает определенный уровень прав на папку текущему пользователю(700 - полные права)",
        "sudo setfacl -m user:kas:rw /var/run/docker.sock": "убирает sudo для докера, если добавление в группу не помогло",  # noqa
        "su имя": "переключает на указанного пользователя(команда exit выйдет до уровня root пользователя = ctrl + d)",  # noqa
        "mkdir -p .ssh": "создает папку, где .ssh - название папки",
        "pwd": "показывает активную дирректорию",  # noqa
        "echo 'текст' >> ~/.ssh/authorized_keys": "пишет в указанное место",
        "echo": "команда пишет что либо",
        "cat ~/.ssh/authorized_keys": "читает что либо(в данном случае файл)",
        "cp -fv timeweb timeweb.pub ~/.ssh/": "cp file1 file2 - копирует файлы в указанную папку или файл.",  # noqa
        "rm -r env/": "удаление виртуального окружения",
        "touch name": "создает файл с указанным названием",
        "nano name": "открывает файл в текстовом редакторе nano",
        "openssl rand -hex 32": "Выдаст рандомную длинную строчку. Можно использовать как приватный ключ или что-то вроде того.",  # noqa
        "apt update && apt upgrade -y && apt install -y openssh-client": "Обновит установщик и установит openssl клиент, если его нет",
        "sudo ssh -i timeweb root@ip_address": "Подключение к удаленном серверу по ссш ключу, можно без ключа.",  # noqa
        "sudo scp -r /root/folder/* root@ip:/root/folder/": "Отправить файлы '*' на удаленный сервер, -r - включая внутренние папки и их содержимое.",
        "sudo apt update": "скачать обновления приложения для поиска приложений",
        "sudo apt upgrade": "установить обновления приложения для поиска приложений",
        "sudo apt install python3-virtualenv": "установить виртуальное окружение",
        "pip freeze > requirements.txt": "Используется для создания или обновления списка необходимых библиотек",
        "pip install -r requirements.txt": "Догружает все необходимые библиотеки из файла в проект",
        "pip list": "Посмотреть список установленных библиотек",
        "pip install python-dotenv": """ модуль для работы с переменными окружения:
                1) Создается файл .env куда скидываются все эти переменные.
                2) from dotenv import load_dotenv - подгружает данные из файла с переменными.
                3) os.getenv('имя_переменной') - команда получения переменной в коде.
                4) Создается .env.template с шаблоном переменных .env который нужно будет создать другим.
            """,
        "pip install rsync | rsync -V": "установить и проверить версию установленного rsync. Нужен для синхронизации дирректорий сервера и локалки.",  # noqa
        "rsync -a dir1 dir2": """ синхронизация каталогов на 1 машине. 
                -r - рекурсивная синхронизация, 
                -z - сжатие данных, 
                -P - показать прогресс синхронизации,
                -a - режим архива, тоже, что и это: -rlptgoD, 
                -e - нужен для установки параметром при подключении через ssh.
            """,  # noqa
        "rsync -a local_dir user@ip_address:final_dir": "синхронизация с удаленной дирректорией(можно в обратку: реверс)",  # noqa
        "rsync -e 'ssh -i timeweb' -Paz user@ip_address:final_dir local_dir": "работает вместе с вводом ssh сразу и его данными",  # noqa
        "curl --verbose URL": "выведет процесс соединения со всей информацией к указанному URL (например google.com)",  # noqa
        "curl http://0.0.0.0:5050/hello/andrei": "Делает запрос в приложение в контейнер по адресу и показывает его результат",  # noqa
        "flask run -h ip_address": "запуск фласк сервера с указанным хостом",  # noqa
        "host URL": "вернет IP-адресс указанного URL (например google.com)",  # noqa
        "python3 -m virtualenv -p python3 venv": "устанавливает виртуальное окружение в активной дирректории",  # noqa
        "source venv/bin/activate": "запускает виртуальное окружение",
        "python -m venv venv": "Создает виртуальное окружение с указанной папкой 'venv'",
        r".\\venv\Scripts\activate": "Запускает виртуальное окружение",  # noqa
        "pip install poetry": "Аналог pip но с повышенной защитой. Дополнительно смотрит, что бы версии библиотек не заменяли, следит за зависимостями. Лучше использовать его.",
        "poetry init": "Задает несколько вопросов для инициализации проекта и информации о нем. no | no | yes",
        "poetry add 'django@4.2.0'": "Устанавливает нужные библиотеки и их зависимости и добавляет в свой файл в хешированном виде.",  # noqa
        "poetry install": "Загрузка всех зависимостей в проект. После этого можно удалить requirements.txt, т.к. он больше не нужен.",
    }  # Тут классические консольные команды. Приоритетно для Ubuntu - Linux. # noqa

    git_info = {
        "flow": {
            1: """
            git branch develop # создание ветки develop
            git push -u origin develop # отправка ветки develop в репозиторий
            """,  # При создании проекта от ветки main создается ветка develop. # noqa
            2: """
            git checkout develop # переключиться на ветку develop
            git checkout -b feature_branch # создать от нее ветку feature для работы на новой функцией
            git merge feature_branch # после разработки надо переключиться обратно на develop и сделать merge ветки с функцией
            """,  # При разработке новый функции от ветки develop создается ветка feature, которая после разработки сливается с develop. # noqa
            3: """  # когда все работы завершены и баги исправлены, release сливается сразу и с main и с develop, а потом удаляется, это идеальное место для git pull.
            git checkout develop # перепрыгнуть на develop
            git checkout -b release/0.1.0 # создать release ветку
            git checkout main # перепрыгнуть в main
            git merge release/0.1.0 # слить release с main
            git checkout develop # перепрыгнуть в develop
            git merge release/0.1.0 # слить release с develop
            git branch -d release/0.1.0 # удаление ветки release
            """,  # Когда подходит время релиза - от develop создается ветка release, на этом этапе нельзя добавлять новый функции, можно лишь фиксить баги. # noqa
            4: """
            git checkout main # перепрыгнуть в main
            git checkout -b hotfix_branch # создать ветку hotfix для исправления багов
            git checkout main # перепрыгнуть в main
            git merge hotfix_branch # слить hotfix в main
            git checkout develop # перепрыгнуть в develop
            git merge hotfix_branch # слить hotfix в develop или release в зависимости от обстоятельств
            git branch -D hotfix_branch # удалить ветку hotfix
            """,  # При необходимости от main создается hotfix для фикса крит. проблем, после ее нужно слить с main и develop (или release, если он сейчас есть). # noqa
        },  # Метод больше подходит для структуры "монолит", т.к. на микросервисах использовать его немного затруднительно. # noqa
        "trunk_based": """
        Заключается в том, что существует основная магистральная ветка main, в которую уже потом вливаются все остальные изменения в небольших объемах и с частой периодичностью (т.е. маленькие 
            коммиты и примерно каждый день), так же с таким методом важно часто проводить асинхронные проверки кода на наличие ошибок, что бы максимально быстро их исправлять. 
        Краткосрочные модульные и интеграционные тесты выполняются в процессе разработки и после слияния кода. 
        Более длительные и комплексные сквозные тесты выполняются на более поздних этапах конвейера на основе всего раздела проиндексированных файлов или рабочей среды. 
        После слияния ветки ее нужно удалить и желательно поддерживать не более 3 доп. веток одновременно. 

        CI - когда пушится коммит в репозиторий, тот запускает всякие валидаторы и тесты, что бы проверить работоспособность коммита и ничего не сломать.
        CD - после успешной интеграции от CI весь код автоматически отправляется в работу и доставляется на нужные сервисы и т.д.

        Эти CI/CD работают в виде конвейера, который называется pipeline, он и хранит в себе шаблон автоматизации, например: plan -> develop -> build -> test -> deploy -> operate. Популярные варианты 
            для реализации такой автоматизации: 1) Jenkins, 2) GitLab CI/CD
        """,  # Магистральная разработка(CI/CD). Этот метод подходит для архитектуры на микроприложениях. # noqa
        "commands": {
            "git add .": "добавление всех папок и файлов в индекс.",
            "git restore --staged название": "извлечение файла из индекса",
            "git restore название": "откатить только что измененный файл(не закомиченный и не в индексе)",  # noqa
            "git clean -f": "удалить изменения в файлах в рабочей дирректории, даже которые не отслеживаются гитом",  # noqa
            "git status": "проверка на наличие проекта в репозитории и на наличие не сохраненных изменений.",
            "git init": "создание репозитория проекта в папке.",
            "git log": "история комитов",  # noqa
            "git show": "просмотр информации и сохранений репозитория и прочую информацию(автор, дата и время и т.д.)",
            "git clone ссылка": "скачать репозиторий",
            "git push -u origin master(или main)": "впервые выложить репозиторий и связать локальный с удаленным.",
            "git remote add origin 'ссылка на репозиторий'": "добавить ссылку на репозиторий",
            "git push": "выложить новинки репозитория",
            "git pull": "скачать новинки репозитория",
            "git rm --cached(может надо -f) название": "удалить файл из отслеживания гитом",
            "git revert хеш_коммита": "отменить конкретный коммит",  # noqa
            "git revert --no-commit хеш_коммита": "отмена нескольких коммитов",  # noqa
            "git checkout 'название'": "перейти в ветку",
            "git checkout -b название": "создать ветку и перейти в нее",
            "git checkout хеш_коммита название_файла": "откат файла к указанному коммиту",  # noqa
            "git stash": "отложить изменения без коммита",  # noqa
            "git stash pop": "вернуть отложенные изменения",
            "git stash list": "список всех отложенных изменений",
            "git stash drop номер изменения": "удалить отложенное изменение",
            "git branch": "все ветки",
            "git branch -d название": "удаление ветки",
            "git branch -m название": "переименование ветки",
            "git branch -a": "все ветки вместе с удаленным репозиторием",
            "git reset хеш_коммита(или head~1 - последний 1 коммит)": "сброс коммита и перенос его в индекс",  # noqa
            "git reset(--mixed) хеш_коммита": "отмена коммитов до указанного и возвращает в рабочую дирректорию",  # noqa
            "git reset --soft хеш_коммита": "отмена коммитов до указанного и возвращение изменений в индекс",  # noqa
            "git reset --hard хеш_коммита": "полное удаление всех коммитов после указанного",  # noqa
            "git reset --merge хеш_коммита": "вырезает слитые коммиты до указанного",  # noqa
            "git merge название": "слияние указанной ветки -> активной",
            "git merge --abort": "откат слияния веток",
            "git commit - m 'сообщение'": "сохранение изменений в репозитории с комментарием об изменении.",
            "git commit --amend --no-edit": "добавить файл из индекса в последний коммит",
            "git commit --amend -m 'коммент'": "изменить комментарий актуального коммита",  # noqa
            "git diff название_файла(если нужно)": "просмотр изменений между коммитами",  # noqa
            "git diff имя_файла_1 имя_файла_2": "просмотр изменений между файлами между коммитами",  # noqa
            "git diff старый_хеш_коммита новый_хеш_коммита(можно первые 4 символа) имя_файла(если нужно)": "просмотр изменений между коммитами",  # noqa
            "git blame имя_файла": "история коммитов файла между всеми пользователями",
        }  # Консольные команды для Git. # noqa
    }  # Информация по Git. # noqa

    ssh_keys = """ 
            Тут некоторая информация по созданию и использованию SSH ключей
            ===============================================================================================================
            Алгоритм установки SSH-ключа для получения бесконечного и простого доступа к конкретным ресурсам:

            1. ssh-keygen -t ed25519 -C "комментарий" - создание: приватного файла и .pub - публичного файла ключей. Создается в папке user'a, не root'a: mrkir ~/.ssh/ (создать если нет) # noqa
                  ssh-keygen -t rsa -b 2048 -C "TimeWeb Machine" -f timeweb | Ключ для облачного сервера # noqa
                  Параметр -t означает тип ключа, то есть алгоритм цифровой подписи.
                  Параметр -b означает размер ключа в битах.
                  Параметр -C означает комментарий, который мы прикладываем к ключу. Можно сказать, это его имя.
                  Параметр -f означает название файла ключа.

            2. Создать папку конфига для ключей если ее нет: nano ~/.ssh/config , Установить настройки для файла конфига, где IdentityFile - пути к приватным ключам:
                Host gitlab.com
                  User git
                  Hostname gitlab.com
                  IdentityFile ~/.ssh/WorkMachine
                  TCPKeepAlive yes
                  IdentitiesOnly yes

            3. Файлу конфига нужно выдать права 600 уровня, что бы он мог работать. Команда: chmod 600 ~/.ssh/config
            4. Открытый ключ нужно добавить в аутентификацию на сайте, например gitlab.com. Просто копируется ВСЁ содержимое файла с ключом .pub # noqa

            (файл с конфигом для подключения к серверу без ввода пути для ключа (config для подключения к серверу без ввода пути для ключа: хранится рядом с ключом), его шаблон: # noqa
                Host <ip_address_of_your_machine>
                  User <your_remote_system_user_name>
                  IdentityFile ~/.ssh/timeweb

            ssh -T git@github.com - проверит статус работоспособности ключа.
            ssh-add -l -E md5 - покажет все активные ключи.
            ===============================================================================================================
            Подключение по ссш ключу к конкретному пользователю и залив файлов на сервер:
            sudo ssh -i timeweb root@ip_address - подключение к указанному пользователю по ссш ключу
            sudo scp -i timeweb абс_путь_до_файла_с_моего_пк user@ip_address:путь_до_файла_на_сервере - заливает файл на сервер(можно и скачать в обратную: реверс) # noqa
            sudo scp /root/folder/* root@ip:/root/folder/ - содержимое локальной folder уйдет в folder на сервер
            -r /root/folder/* - позволяет копировать целые папки; timeweb - имя файла ключа: timeweb, timeweb.pub
            -1 - использовать протокол SSH1;
            -2 - использовать протокол SSH2;
            -B - пакетный режим для передачи нескольких файлов;
            -C - включить сжатие;
            - l - установить ограничение скорости в кбит/сек;
            -o - задать нужную опцию SSH;
            -p - сохранять время модификации;
            -r - рекурсивное копирование директорий;
            -v - более подробный режим.
        """  # Тут показан пример создания и использования ключа SSH. # noqa

    script_to_exe = r""" 
        Что бы портировать скрипт в .exe файл, можно использовать библиотеку pip install pyinstaller, она требует для работы Microsoft Visual C++ для Visual Studio. 
        После установок можно использовать:
            pyinstaller --onefile your_script.py - что бы скомпилировать 1 файл (будет в папке dist),
            pyinstaller --noconsole --onefile hello.py - что бы при запуске не было консоли 
            
        Так же можно сделать автозапускалки в виде батников для Windows | Ubuntu:
            @echo off | #!/bin/bash
            pip install -r requirements.txt
            python3 -m script.py
            pause (только для windows)
        
        Установка переменной окружения для Python:
            Откройте меню "Пуск".
            Найдите "Windows PowerShell" в списке приложений.
            Щелкните правой кнопкой мыши на "Windows PowerShell".
            Выберите "Запуск от имени администратора".
            Ввести команду:
                $env:PATH += ";C:\Users\admin\AppData\Local\Programs\Python\Python310\Scripts"
                [Environment]::SetEnvironmentVariable("PATH", $env:PATH, "Machine")
        """  # Тут описан один из вариантов как закодировать скрипт в .exe исполняемый файл. # noqa

    pip_for_windows = r""" # Эта команда установит chocolate на windows 10 через консоль от имени администратора:
            @"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -InputFormat None -ExecutionPolicy
            Bypass -Command "[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex
            ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))" && SET
            "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"

            Однако у него есть доп. зависимости:
            1) .NET Framework 4.x+.
            2) Windows 7+/Windows 2003+ (включая Server Core, но исключая Windows Nano Server).
            3) Учетная запись пользователя с правами администратора.
            После установки он работает в той же обычной консоли от имени администратора: choco --help
        """  # Тут показано, как установить и использовать аналог pip для windows: chocolate. # noqa

    module_re = {
        "params": {  # Пример: (?P<a>[abc]) - достает какое-то значение и возвращает его под 'a' # noqa
            r".": r"Один любой символ, кроме новой строки \n.",
            r"?": r"0 или 1 вхождение шаблона слева",
            r"+": r"1 и более вхождений шаблона слева",
            r"*": r"0 и более вхождений шаблона слева",
            r"\w": r"Любая цифра или буква (\W — все, кроме буквы или цифры)",
            r"\d": r"Любая цифра [0-9] (\D — все, кроме цифры)",
            r"\s": r"Любой пробельный символ (\S — любой не пробельный символ)",
            r"\b": r"Граница слова",
            r"[..]": r"Один из символов в скобках ([^..] — любой символ, кроме тех, что в скобках)",
            r" \ ": r"Экранирование специальных символов (\. означает точку или \+ — знак 'плюс')",
            r"^ и $": r"Начало и конец строки соответственно",
            r"{n,m}": r"От n до m вхождений ({,m} — от 0 до m)",
            r"a|b": r"Соответствует a или b",
            r"()": r"Группирует выражение и возвращает найденный текст",
            r"\t, \n, \r": r"Символ табуляции, новой строки и возврата каретки соответственно"
        },  # Синтаксис и его значения.
        "methods": {  # r"" - off экранирование спец. символов ('\n' не будет переносом на новую строку). С помощью '\' можно экранировать 1 символ отдельно и вызывать шаблон по номеру. # noqa
            "re.search": "Проверяет, есть ли 'val1' в 'val2'.",  # Возвращает: True / False # noqa
            "re.match": "Собирает разную информацию в отношении 'val1' к 'val2'.",  # Возвращает класс с методами. Например .span(): (1, 3) - индексы расположения. # noqa
            "re.findall": "Ищет все совпадения в тесте.",  # Возвращает список. Например: ['1', '2']. # noqa
            "re.sub": "Заменяет 'val1' на 'val2' в сопадениях 'val3'.",  # Возвращает замененную строку. Пример: '123' -> '1A3'. # noqa
            "re.subn": "Заменяет 'val1' на 'val2' в сопадениях 'val3'.",  # Дополнительно возращает кол-во изменений. Пример: ('1A3', 1). # noqa
        },  # Методы и их значения.
    }  # Информация по поводу модуля 're'.

    mark_directory_as = {
        "Sources Root": "Основной код проекта.",  # noqa
        "Test Sources Root": "Тесты для проекта.",  # noqa
        "Resource Root": "Ресурсы приложения. Файлы в этом каталоге и его подкаталогах могут быть ссылаться относительно этого каталога без полного пути.",  # noqa
        "Namespace Package": "Разрешает импорты внутри этой директории.",  # noqa
        "Template Folder": "Шаблоны Web-проекта. Тут хранятся типа заготовки для html и т.д. Полезен например в Django, при указании нужно выбрать язык шаблонов 'Django'.",  # noqa
        "Excluded": "Указывает, что эту часть кода не нужно учитывать при работе и компиляции кода.",  # noqa
    }  # Параметры отметки папки проекта в PyCharm -> 'Mark Directory as'. # noqa

    development_principe = {
        "SOLID": {
            "S": """ В коде в тех же классах используется 1 основная задача. Например в случае работы с сообщениями должен быть 
                класс для отправки сообщений, класс для обработки. Такой подход упростит тестирование и расширение классов. Принципы нарушения:
                    а) У класса много переменных экземпляра;
                    б) В классе много открытых методов;
                    в) Каждый метод класса использует разные переменные экземпляра;
                    г) Конкретные задачи делегируются закрытым методам.
                """,  # SRP — Single Responsibility Principle (Принцип Единой Ответственности). # noqa
            "O": """ Классы должны быть построены так, что их можно было модифицировать не изменяя код класса на прямую (т.е. наследованием к другим классам). Например есть 
                класс кодировщик форматов, в нем обрабатываются json, yaml, xml и другие, что бы добавить в такой класс новый формат - придется менять сам класс напрямую, а если вынести логику 
                обработки формата в отдельный класс, то можно будет создать дополнительный класс с логикой обработки нового формата (Первое правило грубо говоря в действии). Принципы нарушения:
                    а) Условия, использующие одни и те же переменные или константы, повторяются внутри класса или связанных классов;
                    б) Класс содержит жёстко запрограммированные ссылки на другие классы или имена классов;
                    в) У класса есть защищённые свойства или методы, позволяющие изменять его поведение путём переопределения состояния или поведения.
                """,  # OCP — Open / Closed Principle (Принцип Открытости / Закрытости). # noqa
            "L": """  Наследующие классы, или подклассы, должны заменять свои базовые, или родительские, классы. 
                Например есть класс А с функцией абв, тогда его наследник класс Б(А) должен иметь функцию абв с той же 
                логикой, что бы при вызове как А, так и Б, функция абв работала по своей задумке не вызывая ошибок или разногласий.
                """,  # LSP — Liskov Substitution Principle (Принцип подстановки Барбары Лисков). # noqa
            "I": """ Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Например есть класс с несколькими функциями и есть 
                другие классы, которые используют различные комбинации этих функций. При наследовании всех других классов от первого, они все получают наследством 
                кучу не нужных функций, которые придется обрабатывать, а это плохо. Для решения этой проблем можно вынести функции в отдельные классы, и наследовать 
                другие классы уже от нужного набора классов-функций. Собственно в итоге у каждого из других классов будут родительские классы, несущие только нужные функции.
                """,  # ISP — Interface Segregation Principle (Принцип Разделения Интерфейса). # noqa
            "D": """ 
                Класс должен зависеть от абстракций, а не от конкретных реализаций. Например есть задача: 
                    - необходимо создать список чисел от 1 до n;
                    - числа, которые делятся на 3, следует заменить на Fizz; 
                    - числа, которые делятся на 5, следует заменить на Buzz; 
                    - числа, которые делятся на 3 и 5, следует заменить на FizzBuzz.

                Что бы решить такую задачу и при этом следовать правилам, которые запрещают изменять изначальную функцию и т.д. Нужно сделать следующее:
                    а) Создать класс, в котором будет функция, отвечающая за генерацию списка чисел, функция для добавления нового правила, функция проверки правил.
                    б) Этот класс наследуется от других классов, которые имеют функции проверки конкретных правил, изменения результата при прохождении этих правил.
                    в) Класс, который является абстрактным шаблоном для классов с правилами.
                Результат в виде кода выглядит примерно как в примере.
                """,  # DIP — Dependency Inversion Principle (Принцип Инверсии Зависимостей). # noqa
            "primer": """
                    from abc import ABC, abstractmethod

                    class RuleInterface(ABC):  # Класс-шаблон для классов с правилами.
                        @abstractmethod
                        def matches(self, number) -> bool:
                            pass

                        @abstractmethod
                        def get_replacement(self) -> str:
                            pass

                    class FizzBuzzRule(RuleInterface):  # Один из классов с правилами.
                        def matches(self, number) -> bool:
                            return number % 3 == 0 and number % 5 == 0

                        def get_replacement(self) -> str:
                            return 'FizzBuzz'

                    class FizzBuzz:  # Основной рабочий класс с главной логикой. fizzBuzz.addRule(FizzBuzzRule()) - добавит правило, которые будет работать в классе при этом не меняя класс или еще что-то.
                        def __init__(self):
                            self.rules = []

                        def addRule(self, rule: RuleInterface) -> None:
                            self.rules.append(rule)

                        def generate_list(self, limit: int) -> list:
                            fizz_buzz_list = []
                            for number in range(1, limit + 1):
                                fizz_buzz_list.append(self.generate_element(number))
                            return fizz_buzz_list

                        def generate_element(self, number: int) -> str:
                            for rule in self.rules:
                                if rule.matches(number):
                                    return rule.get_replacement()
                            return str(number)

                    return RuleInterface, FizzBuzzRule, FizzBuzz
                """,  # Пример буквы D. # noqa
        },  # Целый набор правил хорошего программирования. # noqa
        "DRY": """ 
            Не стоит плодить много однотипных функций с одинаковым функционалом, лучше отдать приоритет одной функции с более сложным функционалом, т.к. такой подход в будущем 
            сделает проще процессы тестирования, разработки и поддержания кода. Например: нужно написать функцию получения цены со скидкой, функция будет выглядеть так:

                def get_price_with_discount(price):
                   return price * 0.9

            Однако если скидок будет много, придется дублировать функцию, поэтому для решения этой проблемы лучше будет добавить дополнительный параметр скидки 
            вместе 0.9, таким образом эта функция подойдет всем товарам независимо от их скидки:

                def get_price_with_discount(price, discount):
                    return price * (1 - discount)
            """,  # DRY - Don’t Repeat Yourself (Не Повторяйте Себя). # noqa
        "KISS": """ По сути этот принцип - набор следующих правил:
            1) Не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться.
            2) Бессмысленно закладывать в проект избыточные функции про запас, которые, возможно, когда-нибудь кому-либо понадобятся.
            3) Не стоит подключать огромную библиотеку, если вам нужна из неё лишь пара функций.
            4) Декомпозиция чего-то сложного на простые составляющие — архитектурно верный подход (здесь KISS перекликается с DRY).
            5) Абсолютная математическая точность или предельная детализация нужны не всегда — большинство систем создаются не для запуска космических шаттлов. Данные можно и нужно обрабатывать 
                с той точностью, которая достаточна для качественного решения задачи, а детализацию стоит выдавать в нужном пользователю объёме, а не в максимально возможном.
            """,  # Принцип KISS - Keep It Short and Simple, Stupid (Делайте Вещи Проще). # noqa
    }  # Принципы программирования. Это набор правил для создания качественного кода. # noqa

    pycharm = {
        "shift + f6": "Переименовать объект и все обращения к нему",
        "alt + insert": "Сгенерировать какой то код (тест/геттер/сеттер...)",
        "alt + f7": "Посмотреть, где используется объект",
        "ctrl + /": "Закомментировать строку",
        "ctrl + Y": "Удалить всю строку",
        "ctrl + D": "Дублирование строки",
        "ctrl + E": "История измененных файлов",
        "ctrl + G": "Перейти к конкретной строчке по номеру",
        "ctrl + O": "Удалить все неиспользуемые импорты в файле",
        "ctrl + W": "Выделить блок с повышением уровня при каждом нажатии",
        "ctrl + R": "Найти и заменить в файле",
        "ctrl + F": "Найти в файле",
        "ctrl + N": "Найти класс в проекте и перейти к нему",
        "ctrl + B/click": "Перейти к реализации самого первого объекта",
        "ctrl + alt + L": "Быстрое форматирование кода (отступы...)",
        "ctrl + alt + T": "Оборачивает выделенный текст в выбираемый блок (if, for...)",
        "ctrl + alt + M": "Выносит выделенный текст в отдельный метод",
        "ctrl + alt + V": "Выносит выделенный текст в отдельную переменную",
        "ctrl + alt + C": "Выносит переменную в глобальное окружение",
        "ctrl + alt + left/right": "Перемещение по истории активности в проекте",
        "ctrl + alt + B/click": "Перейти к реализации выбираемого объекта",
        "ctrl + shift + W": "Снизить уровень выделения блока",
        "ctrl + shift + N": "Найти файл по названию",
        "ctrl + shift + E": "Последние блоки, с которыми работали",
        "ctrl + shift + U": "Сменить регистр выделенных слов",
        "ctrl + shift + V": "История буфера обмена",
        "ctrl + shift + C": "Копировать полный путь до активного файла",
        "ctrl + shift + H": "Посмотреть наследников класса",
        "ctrl + shift + стрелка": "Перенос строки вверх/вниз",
    }  # Сочетания кнопок для PyCharm. # noqa


class Python:
    """ Класс, в котором хранятся некоторые небольшие шаблоны. Сложных вещей тут нет. """
    @staticmethod
    def f_string():  # noqa
        """ Тут некоторые фишки с использованием f-string """
        from datetime import datetime

        print(f'{10000000:_}')  # result: 10_000_000 # noqa
        print(f'{"var":>20}')  # result:                  var # noqa
        print(f'{"var":^20}')  # result:           var         # noqa
        print(f'{"var":#>20}')  # result:####################var # noqa
        print(f'{datetime.now():%d.%m.%y (%H:%M:%S)}')  # result: 21.03.24 (10:40:04) # noqa
        print(f'{datetime.now():%c}')  # result: Fri Feb 9 10:40:20 2024 # noqa
        print(f'{123.456:.2f}')  # result: 123.46 # noqa
        print(f'{12345.6789:,.2f}')  # result: 12,345.68 # noqa
        print(f'{bool(1) = }')  # result: bool(1) = True # noqa
        print(f'{value!r}')  # result: 'value' # noqa

    @staticmethod
    def lambdas():  # noqa
        """ Лямбда и ее устройство """

        def f(num): return num * 2  # лучше использовать такой формат вместо лямбда функций # noqa

        x = lambda num: num * 2  # lambda a - значит полученное для x значение помещается в доп переменную a, после двоеточния пишутся инструкции. Однако лучше использовать функции. # noqa
        print(x(5))  # выводит 10, т.к. полученное число 5 помещается в num, после чего умножается на 2 # noqa

    @staticmethod
    def console_args():  # noqa
        """ Тут показано как можно обрабатывать консольные аргументы при запуске скрипта, например: python file.py -h или python file.py default """
        import sys

        if "-h" in sys.argv[1:]:
            pass

    @staticmethod
    def class_info():  # noqa
        """ Классы и их особенности, а так же getter и setter с грамотным оформлением """
        from abc import ABC

        class Addon(ABC):  # Класс, который не создается в качестве переменных называется абстрактным и всегда наследуется: from abc import ABC # noqa
            value3 = 0

        class User(Addon):  # noqa
            """ Сокрытие данных является действием из инкапсуляции. Важно для защиты приватных данных """
            __value = 0  # Двойное подчеркивание в начале означает, что эта переменная используется только локально. Желательно менять такое значение только через геттеры и сеттеры. # noqa
            _value2 = 0  # Одно подчеркивание в начале означает, что эта переменная может использоваться в дочерних классах, но нежелательно использовать в основном коде. # noqa

            def get_value(self):  # Геттер, или способ получения скрытого-локального параметра
                return self.__value

            def set_value(self, value):  # Сеттер, или способ изменения значения скрытого-локального параметра
                self.__value = value

        User.get_value()  # стардартный способ получения данных без использования декоратора @property # noqa
        User.set_value()  # стардартный способ получения данных без использования декоратора @property # noqa

        class User2(Addon):  # noqa
            """ Сокрытие данных вместе с декораторами. Делает более удобную работу с переменными за пределами класса """  # noqa
            value = 0  # тут уже не нужны два нижних подчеркивания вначале, все работает и без них

            @staticmethod  # декоратор для статических методов. Так же у таких методов убирается self из подаваемых аргументов. СТАРОМОДНАЯ ФИЧА # noqa
            def get_number():  # Статический метод, значит он никак не взаимодействует с атрибутами класса, поэтому ему дается декоратор и убирается self из аргументов # noqa
                return "number"

            @classmethod  # декоратор для статических методов. Так же у таких методов заменяется self на cls в подаваемых аргументах. НОВОМОДНАЯ ФИЧА # noqa
            def get_num(cls):  # Статический метод, значит он никак не взаимодействует с атрибутами класса, поэтому ему дается декоратор и self заменяется на cls # noqa
                return "num"

            @property  # декоратор для геттеров
            def value(self):  # Геттер, или способ получения скрытого-локального параметра # noqa
                return self.__value

            @value.setter  # декоратор для сеттеров # noqa
            def value(self, value):  # Сеттер, или способ изменения значения скрытого-локального параметра
                self.__value = value  # noqa

        User2.value  # способ получениях данных вместе с декоратором @property, value - передаваемое в декоратор название функции # noqa
        User2.value = 1  # способ установки данных вместе с декоратором @setter, value - изменяемое значение переменной # noqa

    @staticmethod
    def class_contextmanager():  # noqa
        """ Класс: контекст-менеджер """
        from contextlib import contextmanager

        class Timer:
            """ Класс таймера в виде контекст-менеджера, можно юзать в виде: "with Timer() as t1:"... """

            def __init__(self) -> None:  # место инициализации таймера, тут можно записать вступительную речь и сделать регистрацию всех необходимых переменных перед двоеточием # noqa
                self.start = None

            def __enter__(self) -> 'Timer':  # тут фиксируется прогресс после двоеточия. Возвращает себя(т.е. сам класс) # noqa
                self.start = time.time()  # noqa
                return self

            def __exit__(self, exc_type, exc_val, exc_tb):  # тут фиксируется результат после работы контекст менеджера
                print(time.time() - self.start)  # noqa
                return True  # Необязательная строка, нужна только, что бы пропускать ошибки

        @contextmanager  # декоратор, добавляющий функции методы next, iter, тем самым превращая функцию в стандартный итератор # noqa
        def next_num(num: int) -> Iterator[int]:  # noqa
            yield num + 1

    @staticmethod
    def iterators():  # noqa
        """ Простенький итератор, генератор отличается тем, что в нем значения возвращаются через yield """

        class Iterator:  # noqa
            def __init__(self, number: int) -> None:  # тут создаются все необходимые переменные при инициализации итератора # noqa
                self.number = number
                self.count = 0

            def __iter__(self) -> iter:  # тут возвращается сам итератор # noqa
                return self

            def __next__(self) -> int:  # тут с каждой итерацией выполняются определенные инструкции # noqa
                if self.count < self.number:
                    self.count += 1
                    return self.count
                else:
                    raise StopIteration

    @staticmethod
    def generators():  # noqa
        """ Тут информация о генераторах """

        def one_generator():  # noqa
            """ Тут описание реализации одного простенького генератора """

            def generator() -> Generator[int, int, str]:  # [возвращает через yield, принимает через yield, возвращает на StopIteration] # noqa
                while True:
                    item = yield
                    print(f'{item=}')
                    if item == 9:
                        return 'stop iteration'  # return завершает процесс итерации выбросом StopIteration # noqa

            gener = generator()
            next(gener)  # переводит декоратор на строчку ниже (под while True) # noqa
            for i in range(1, 10):  # во входящий yield подает i с помощью метода send # noqa
                gener.send(i)

        def duble_generator():  # noqa
            """ Тут описание двойного генератора, в котором значение передает по внутренним генераторам. """

            def first():  # noqa
                val = yield
                print(f'{val=}')

            def second():  # noqa
                gener = first()
                yield from gener

            gen = second()
            gen.send(None)
            gen.send('my string')

    @staticmethod
    def decorators():  # noqa
        """ Тут все, что касается декораторов """

        def classic_decorator():  # noqa
            """ Стандартные декораторы в виде класса и функции """
            from typing import Callable, Any
            import functools

            class DecoratorClass:  # noqa
                """Декоратор в виде класса"""

                def __init__(self, func: Callable) -> None:  # метод инициализации, принимает функцию
                    functools.update_wrapper(self, func)
                    self.func = func
                    self.number = 0

                def __call__(self, *args, **kwargs) -> Callable:  # возвращает функцию как класс: name()
                    self.number += 1
                    print(self.number)
                    return self.func(*args, **kwargs)

            def decorator_function(func: Callable) -> Callable:  # noqa
                """Декоратор в виде функции"""

                @functools.wraps(func)
                def wrapped_func(*args, **kwargs) -> Any:
                    return func(*args, **kwargs)

                return wrapped_func

        def decorator_for_decorators():  # noqa
            """ Декоратор для декоратора """
            from typing import Optional, Callable
            import functools

            def decorator_for_func_decorator(_func: Optional[Callable] = None, *, status: str) -> Callable:  # noqa
                """ Декоратор для декоратора в виде функции """

                def decorator(func: Callable) -> Callable:
                    @functools.wraps(func)
                    def wrapped_func(*args, **kwargs):
                        have = status  # noqa
                        return func(*args, **kwargs)

                    return wrapped_func

                if _func is None:
                    return decorator
                else:
                    return decorator(_func)

            def decorator_for_class():  # noqa
                """ Декоратор для класса """

                def createtime(cls):  # вспомогательный декоратор регистрации времени создания и инициализации класса # noqa
                    """ Декоратор класса, выводит время создания инстанса класса """  # noqa

                    @functools.wraps(cls)
                    def wrapper(*args, **kwargs):
                        instance = cls(*args, **kwargs)
                        print(datetime.utcnow())  # noqa
                        return instance

                    return wrapper

                def timer(func: Callable) -> Callable:  # декоратор, который должен будет использоваться для вложенных в класс методах # noqa
                    """ Декоратор выводит время работы """

                    @functools.wraps(func)
                    def wrapped(*args, **kwargs):
                        start = time.time()  # noqa
                        result = func(*args, **kwargs)  # noqa
                        print(time.time() - start)  # noqa
                        return result

                    return wrapped

                def for_all_methods(decorator: Callable) -> Callable:  # декоратор для декоратора (для вложенных в класс методов) # noqa
                    """ Декоратор принимает декоратор и применяет его ко всем методам класса """

                    @functools.wraps(decorator)
                    def decorate(cls):
                        for i_method_name in dir(cls):
                            if i_method_name.startswith('__') is False:
                                current_method = getattr(cls, i_method_name)
                                decorated_method = decorator(current_method)
                                setattr(cls, i_method_name, decorated_method)
                        return cls

                    return decorate

                @createtime  # noqa
                @for_all_methods(timer)  # декоратор для класса, который применяет поданный в него декоратор ко всем методам класса # noqa
                class Figure:  # noqa
                    """ Класс для примера """

                    def __init__(self, number: int) -> None:
                        self.number = number

                    def get_number(self):
                        return self.number

        good_decorators: dict = {
            "@staticmethod": "Ставится на методы, которые не используют внутренние параметры класса (self, cls)",
            "@classmethod": "Ставится на методы, которые принимают свой же класс первым аргументом(полностью класс а не его содержимое), его первый аргумент: cls, например cls.name",  # noqa
            "@hybrid_method": "Означает, что атрибут имеет различное поведение, определенное на уровне класса и на уровне экземпляра",
            "@abstractmethod": "Метод для класса, который наследуется от ABC, который не будет создаваться как объект, а только наследоваться другими классами. Его нужно обязательно переопределять."
        }
        return good_decorators

    @staticmethod
    def async_multiprocessing():  # noqa
        """ Тут расписано асинхронное программирование: async, multi-processing, multi-threading. """

        def threads_io(self):  # noqa
            """ Могут быть и синхронными и асинхронными.
            Threads - Потоки, количество одновременных соединений: сотни. Ниже приведены их особенности:

            Плюсы потоков:
                - Общая память (общие переменные и структуры данных)
                - Требуют меньше ресурсов по сравнению с процессами
                - Хорошо в IO-bound операциях(input/output), GUI, web-серверы и сервисы где в языке есть многопоточность

            Минусы потоков:
                - GIL - только один поток может выполняться в настоящее время
                - Плохо для CPU-bound(процессор) вычислений
                - Небезопасно, сложная синхронизация и код под действием ограничений в виде семафоров, spinlocks, критических секций...
                - На обеспечение синхронизации тратится много ресурсов в зависимости от количества потоков """  # noqa

            def classic():  # noqa
                """ Тут классический метод реализации потока. """
                from multiprocessing.pool import ThreadPool

                def task(number):
                    return sum(i ** i for i in range(number))

                pool = ThreadPool(processes=5)  # noqa
                result = pool.map(task, [5000000] * 10)  # noqa
                pool.close()
                pool.join()

            def pool():  # noqa
                """ Тут Pool метод реализации. """
                from multiprocessing import cpu_count
                from multiprocessing.pool import ThreadPool

                def my_func(x, y):  # функция для примера с 2 переменными на входе # noqa
                    return x + y

                with ThreadPool(processes=cpu_count() * 16) as pool:  # noqa
                    threads: list = [pool.apply_async(my_func, (i, i * 2)) for i in range(10)]  # добавляем в список результатов все процессы # noqa
                    waits: list = [thread.wait() for thread in threads]  # ждем, пока выполнятся все процессы # noqa
                    results: list = [res.get() for res in waits]  # смотрим результаты процессов # noqa

        def process_math(self):  # noqa
            """ Могут быть и синхронными и асинхронными.
            Process - Процессы, количество одновременных соединений: десятки. Ниже приведены их особенности:

            Плюсы процессов:
                - Отдельные программы
                - Полностью изолированы(отдельны в виртуальной памяти, открытых файлах, сетевых сокетах...)
                - Простая синхронизация
                - Работают по-настоящему параллельно(блокироваться могут только в коде ядра)
                - Используют все ресурсы процессора

            Минусы процессов:
                - Нет одной структуры данных или переменных
                - Нужна синхронизация (для сложных вычислений например, хотя для web-сервисов и микросервисов сложной синхронизации не надо)
                - Затратные(отдельная копия итератора со своими структурами данных)
                - Зависит от количества ядер процессора """  # noqa

            def classic():  # noqa
                """ Классический способ реализации. """
                from multiprocessing import Pool

                def task(number):
                    return sum(i ** i for i in range(number))

                def apply_async():  # noqa
                    """ apply_async - можно использовать разные функции для вызова, но результаты возвращаются НЕ в том же порядке. """  # noqa
                    pool = Pool(processes=2)  # noqa
                    input_value = 1000
                    result_1 = pool.apply_async(task, [input_value // 2])
                    result_2 = pool.apply_async(task, [input_value // 2])
                    pool.close()
                    pool.join()

                    print(result_1)
                    print(result_2.get(timeout=1))

                def map_async():  # noqa
                    """ map_async - использует одну функцию ко всем аргументам и возвращает результат в том же порядке. """  # noqa
                    pool = Pool(processes=2)  # noqa
                    input_values = [500, 500]
                    result = pool.map_async(task, input_values)
                    pool.close()
                    pool.join()

                    print(result)
                    print(result.get(timeout=1))

            def pool():  # noqa
                """ Pool метод реализации. """
                from multiprocessing import Pool, cpu_count

                def my_func(x, y):  # функция для примера с 2 переменными на входе # noqa
                    return x + y

                with Pool(processes=cpu_count()) as pool:  # noqa
                    processes: list = [pool.apply_async(my_func, (i, i * 2)) for i in range(10)]  # добавляем в список результатов все процессы # noqa
                    waits: list = [proc.wait() for proc in processes]  # apply_async - можно использовать разные функции для вызова, но результаты возвращаются НЕ в том же порядке. # noqa
                    results: list = [res.get() for res in waits]  # смотрим результаты процессов # noqa

        def async_both(self):  # noqa
            """ Async работает примерно следующим образом (на самом деле код тут работает синхронно):
            Запускается код и начинает выполняться определенная функция. Если эта функция в процессе работы зависнет с целью дождаться каких либо результатов(какой-нибудь расчет или ожидание ввода пользователя), то
            код в это время переключится на другую функцию, которая сможет работать в то время, пока первая не может работать. Таким образом итоговое время работы кода может заметно сократиться.
            Количество одновременных соединений: до сотен тысяч. Грубое описание работы: async - ставится при создании функций, await - ставится при вызове таких функций.

            Плюсы async:
            - Выполнение в одном процессе и потоке, требует очень мало ресурсов системы
            - Структуры данных не могут поменяться в рандомное время в другом потоке
            - Отсутствуют накладные расходы на синхронизацию (если путь сопрограммы не предполагает приостановки, стоимость ожидания сопоставима со стоимостью вызова функции - Это намного быстрее, чем итерация цикла)
            - Хорошо в Heavy-IO-bound задачах(ожидая завершения операций ввода или вывода, например парсеры) за счет:
                1) Не блокирующего IO
                2) Огромного кол-ва соединений(например nginx держит 200к+)

            Минусы async:
            - может быть не эффективным для CPU-интенсивных задач(процессор) без доп. механизмов(например процессов).
            - долго выполняемые задачи блокируют выполнение других задач. """
            # await отвечает за запросы данных, типа await my_func(1) это типа return my_func(1) или result = my_func(1) # noqa
            # await так же дожидается данных работы, так что, что бы не вставать на нем - нужно сперва создать список объектов и потом забирать результаты # noqa
            # await ставится всегда для вызова асинхронных функций
            import asyncio
            from typing import Coroutine

            async def my_func(num) -> Coroutine[Any, Any, None]:  # return format: out yield <Any> | in yield <Any> | raise StopIteration # noqa
                await asyncio.sleep(1)  # просто заглушка, аналог обычного time.sleep(1), но не блокирующий. Можно удалить # noqa
                print(f'my_func: {num}')

            async def main():
                done, pending = await asyncio.wait([my_func(1), my_func(2)], return_when=asyncio.FIRST_COMPLETED)  # позволяет задать условие для доп. действия # noqa
                await asyncio.gather(my_func(1), my_func(2))  # ждет пока выполнятся все корутины и только потом отдает result # noqa
                await asyncio.create_task(my_func(1))  # сразу начинает выполнять задачу при создании объекта # noqa
                # task1 = asyncio.create_task(my_func(1)) - создать задачи а потом одновременно их запустить через await task1... получить данные task1.result() # noqa
                async with asyncio.TaskGroup() as group:  # создание группы задач, асинк будет ждать завершения всех задач # noqa
                    for num in range(10):
                        group.create_task(my_func(num))

            # в асинхронке важно использовать асинхронные методы или библиотеки (типа sleep() из asyncio), т.к. это все должно работать асинхронно # noqa
            asyncio.run(main())  # является точкой входа в асинхронное программирование, т.к. асинхронку может вызывать только другая асинхронка # noqa

    @staticmethod
    def documentation():  # noqa
        """ Пример оформления полноценной документации """

        class Property:  # noqa
            """
            Базовый класс, хранит параметр стоимости имущества и работает с ним.

            worth: стоимость имущества

            Args:
                worth(int): стоимость имущества
            """  # noqa

            def __init__(self, worth):
                self.worth: int = worth

            def tax(self):
                """
                метод расчета налога

                Args:
                    worth(int): стоимость имущества

                :return: возвращает налог на Дача
                :rtype: int
                """
                return self.worth / 500

        def main(money, property, property_price):  # noqa
            """
            Функция для взаимодействия с информацией пользователя

            :param money: количество денег, подается пользователем
            :rtype money: int
            :param property: тип имущества, подается пользователем
            :rtype property: int
            :param property_price: стоимость имущества, подается пользователем
            :rtype property_price: int
            :raise Exception: Если имущество за пределами границ, вызывается исключение
            :return: возвращает итоговый налог
            """  # noqa
            tax = 0  # noqa
            if property == 1:
                tax = Apartment(property_price).tax()  # noqa
            elif property == 2:
                tax = Car(property_price).tax()  # noqa
            elif property == 3:
                tax = CountryHouse(property_price).tax()  # noqa
            else:
                raise Exception('Ответом может быть 1, 2 или 3. Попробуйте еще раз.')
            return tax

    @staticmethod
    def requests_session_for_big_count():  # noqa
        """ requests использование session для отправки множества запросов в 1 соединении (обеспечивает скорость работы, т.к. на подключение теряется много времени) """  # noqa

        class BookClient:  # Класс для requests соединения. При инициализации создает соединение, в котором можно уже делать много запросов не закрывая соединение # noqa
            URL: str = 'http://0.0.0.0:5000/api/books'
            TIMEOUT: int = 5

            def __init__(self):  # Тут создается соединение # noqa
                self.session = requests.Session()  # noqa

            def get_all_books(self) -> dict:  # Метод get соединения # noqa
                response = self.session.get(self.URL, timeout=self.TIMEOUT)
                return response.json()

            def add_new_book(self, data: dict):  # метод post соединения # noqa
                response = self.session.post(self.URL, json=data, timeout=self.TIMEOUT)
                if response.status_code == 201:
                    return response.json()
                else:
                    raise ValueError('Wrong params. Response message: {}'.format(response.json()))

        client = BookClient()
        client.session.post(  # Делает post запрос по соединению # noqa
            client.URL,
            data=json.dumps({'title': '123', 'author': 'name'}),  # noqa
            headers={'content-type': 'application/json'}  # указывается тип передаваемых файлов # noqa
        )

    @staticmethod
    def generate_fake_info():  # noqa
        """ Тут описана генерация фейковых данных, а точнее примеры """  # noqa
        from faker import Faker  # noqa

        faker = Faker('RU')  # Указывается страна, под которую будут генерироваться данные, можно ['RU', 'EN'] # noqa
        name = faker.name()
        address = faker.address()
        email = faker.email()
        job = faker.job()
        return name, address, email, job

    @staticmethod
    def csv_file():  # noqa
        """ Тут шаблон работы с csv файлами. """
        import csv
        with open("file.csv", 'a', encoding='utf-8') as csvfile:  # Открывает .csv файл и добавляет в него новые строчки.
            writer = csv.writer(csvfile, delimiter=";", lineterminator="\n")  # ';' - разделитель столбиков, '\n' - перенос на новую строку в конце каждой строки.
            writer.writerow(["column1", "column2", "column3"])

    @staticmethod
    def pdf_file():  # noqa
        """ Тут показан шаблон работы с pdf файлом. pip install pypdf """
        from pypdf import PdfReader  # noqa
        reader = PdfReader("file.pdf")  # Открывает файл pdf
        for page in reader.pages:  # Проходит по всем страницам pdf файла # noqa
            page.extract_text()  # Достает текст со страницы
