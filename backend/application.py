class UniversalInfo:
    """ Класс содержит универсальную информацию для приложений. """
    protection = {
        "info": r"""
                Аутентификация - это процесс проверки учётных данных пользователя (логин/пароль).
                Авторизация - это проверка прав пользователя на доступ к определенным ресурсам.
                HTML знаки для валидации: <>&*'!-?;[]А~'!."%\@
            """,  # Основные определения. # noqa
        "XSS": r""" 
                Пример: через поле 'логин' можно отправить команду, которая может сработать в коде.
                Возможности: запускать разные команды и действия на backend, перенаправлять пользователя на чужой ресурс, воровать данные и т.д.
                Виды: Отраженные (reflected), Хранимые (stored), Атаки на DOM.

                Меры безопасности, которые помогают бороться с XSS уязвимостями:
                1) Использовать render_template() и jsonify() в следующих ситуациях(т.к. они имеют встроенные алгоритмы защиты):
                    а) Когда требуется рендер, например render_template_string() - создает возможности изменения шаблона: render_template_string("<div>%s</div>" % request.args.get("name")) - это уже уязвимость.
                    б) Для возвращения результата из из маршрута(прямо из url) - @app.route("/index/<msg>"), пример вовзращения msg: return render_template("Hello! " + msg)
                    в) Вместо Jinja2 (он обходит защиту Flask) - with open('template', 'r') as fin:, jinja2.Template(fin.read()).render() - Плохо. render_template(fin.read()) - Хорошо.
                    #) Важно помнить, что Flask экранирует только шаблоны с расширениями .html, .htm, .xml или .xhtml, например render_template("unsafe.jinja2") - создаст уязвимость.
                2) Использовать flask.Markup(), если требуется экранирование(с исключениями):
                    а) Вместо фильтра safe: {{ name | safe }} для отображения HTML-кода. Этот фильтр позволяет отображать необработанный HTML-код в шаблоне, что может создать XSS-уязвимость.
                    б) Вместо блока {$ autoescape false %} - Он отключает автоэкранирование для целых частей шаблона, что может создать уязвимости XSS.
                    #) НЕ Использовать flask.Markup() для return содержимого, т.к. он отключает экранирование HTML для возвращаемого содержимого. Просмотрите каждое использование и освободите его с помощью # nosem
                3) Правила при работе с переменными шаблона:
                    а) Аттрибуты HTML без ковычек - заключать в ковычки или помечать с помощью Jinja2. Экранирование HTML не решит эту проблему. Пример: <div class={{ classes }}></div> - плохо.
                    б) Аттрибут href - заключать url-ссылку в url_for(). Пример: <a href="{{ link }}"></a> - плохо. link нужно обработать через url_for(). Ниже будет шаблон для url_for()
                    #) Запретить переменные шаблона в <script> блоках и вместо них использовать to_json фильтр внутри аттрибута данных и JSON.parse()в JavaScript. Пример: <script>var name = {{ name }};</script> - плохо.

                # Шаблон для использования url_for():
                    @app.route('/test1')
                    def one() -> str:
                        result = 'test1'
                        html = '<a href="{{ url_for("one") }}">{{ result }}</a>'
                        return render_template_string(html, result=result)

                # После просмотра(если экранирование не требуется) отметьте строку значком # nosem . Следующая команда запускает оптимизированный набор правил для вашего проекта: semgrep --config p/default
            """,  # XSS - Отправка вредоносного кода на Backend с помощью form в HTML. # noqa
        "CSP": {
            "info": r""" Эту политику можно настраивать как в коде через headers, так и в прямо в HTML в теге <meta>.
                    Например: <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
                """,
            "params": {  # noqa
                "default-src": "В этой директиве задаются белые списки хостов, которые будут автоматически присвоены не заданным директивам.",  # noqa
                "script-srс": "Белый список хостов с которых разрешается загрузка javascript",
                "style-src": "Белый список хостов с которых разрешается загрузка css",
                "object-src": "Белый список хостов с которых разрешается загрузка Flash-подобных плагинов",
                "img-src": "Белый список хостов с которых разрешается загрузка картинок",
                "media-src": "Белый список хостов с которых разрешается загрузка аудио и видео",
                "frame-src": "Белый список хостов с которых разрешается загрузка iframe’ов",
                "font-src": "Белый список хостов с которых разрешается загрузка шрифтов",
                "connect-src": "Спец. директивы для XMLHttpRequest, WebSocket и EventSource. Для каждой из этих директив задаётся список не urls, а hosts, с которыми разрешено общаться браузеру",  # noqa
                "report-uri": "Url, на который будет отсылаться JSON-отчёт о нарушениях политики. Пример отчёта будет показан ниже в статье.",  # noqa
                "##################################################################################": "###########################################################################",
                "'self'": "Определяет текущий хост.",
                "'none'": "Запрещает всё.",
                "'unsafe-inline'": "Используется только script-src и style-src. Разрешает выполнять inline-скрипты на странице. Не рекомендую использовать это ключевое слово, т.к. это дыра безопасности",  # noqa
                "'unsafe-eval'": "Используется только в script-src и разрешает код-генерацию, например: eval, new Function, setTimeout(‘var foo = «bar» ‘, 7)",  # noqa
            },
            "pattern": r"""
                    @app.after_request
                    def add_csp(response: Response):
                        response.headers['Content-Security-Policy'] = "default-src 'self'"  # Откуда можно загружать различные типы ресурсов.
                        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'  # Преобразовать все HTTP-запросы в HTTPS, предотвращая атаки типа "злоумышленник в середине" (MITM).
                        response.headers['X-Content-Type-Options'] = 'nosniff'  # Учитывать тип содержимого ответа вместо обнаружения (что может быть использовано для создания атаки межсайтового скриптинга (XSS)).
                        response.headers['X-Frame-Options'] = 'SAMEORIGIN'  # Запрещает внешним сайтам встраивать сайт в iframe.
                        return response

                    Примеры для Content-Security-Policy:
                        default-src 'self' *.trusted.com
                        default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com
                        default-src https://onlinebanking.jumbobank.com
                        response.headers['Content-Security-Policy'] = "script-src 'unsafe-inline';" # unsafe-inline разрешает скрипты, self разрешает только свои скрипты, чужие в блок.
                """
        },  # Content Security Policy - По сути является параметрами headers для предотвращения разных уязвимостей (XSS...). # noqa
        "CORS": {
            "info": """
                    Пример: запрос с сайта google.com на другой сайт. 
                    Имитация: с сайта google.com можно открыть консоль в браузере и ввести там запрос: fetch('http://127.0.0.1:8080', {method: 'GET'}).then(resp => resp.text()).then(console.log)
                    Решение: заблокировать запросы такого типа и оставить в разрешенных только доверенные.
                """,
            "params": {  # noqa
                "CORS_ALLOW_HEADERS (List/str)": "Заголовки, которые нужно принять от клиента.",
                "CORS_ALWAYS_SEND(bool)": "Если запрос без заголовка Origin - клиент не запрашивал CORS -> можно игнорировать запрос. Но если это правда, наиболее вероятное значение будет установлено.",  # noqa
                "CORS_AUTOMATIC_OPTIONS(bool)": "Только для flask_cors.cross_origin(). Flask-CORS переопределяет обработку OPTIONS по умолчанию Flask, чтобы возвращать заголовки CORS для запросов OPTIONS",  # noqa
                "CORS_INTERCEPT_EXCEPTIONS (bool)": "Стоит ли иметь дело с обработчиками исключений Flask или оставить их в покое (в отношении заголовков CORS).",  # noqa
                "CORS_MAX_AGE (timedelta/int/str)": "Максимальное время, в течение которого этот запрос CORS может быть кэширован. Это значение задается как заголовок Access-Control-Max-Age.",  # noqa
                "CORS_METHODS (List/str)": "Метод(ы), к которым разрешен доступ разрешенным источникам. Они включены в заголовки ответов Access-Control-Allow-Methods на предполетные запросы OPTIONS.",  # noqa
                "CORS_RESOURCES (Dict/List/str)": "Серия регулярных выражений и связанных с ними параметров CORS, которые будут применены к данному пути к ресурсу.",  # noqa
                "CORS_SEND_WILDCARD(bool)": "Если CORS_ORIGINS = '*' и это правда - значение заголовка ответа Access-Control-Allow-Origin: '*' также будет вместо значения заголовка запроса Origin",  # noqa
                "CORS_SUPPORTS_CREDENTIALS (bool)": "Позволяет отправлять аутентифицированные запросы, файлы cookie и учетные данные между доменами. Добавляет заголовок Access-Control-Allow-Credentials.",  # noqa
                "CORS_VARY_HEADER (bool)": "Внедрение заголовка ответа Vary, для которого установлено значение Origin. Это говорит о том, что наши заголовки CORS являются динамическими и не кэшированы.",  # noqa
                "CORS_EXPOSE_HEADERS (List/str)": """Спецификация CORS требует, чтобы сервер предоставил клиенту явные разрешения на чтение заголовков в ответах 
                            CORS (через заголовок Access-Control-Expose-Headers ). Это указывает заголовки, которые будут включены в этот заголовок.""",  # noqa
                "CORS_ORIGINS (List/str/re.Pattern)": """Источник(и), от которых разрешены запросы. Настроенный здесь источник, соответствующий значению заголовка Origin в 
                            предполетном запросе OPTIONS, возвращается как значение заголовка ответа Access-Control-Allow-Origin.""",  # noqa
            },
            "cors_classic": r"""
                    @app.after_request  # Endpoint, который делает дополнительную доработку для всех ответов и решает проблему кросс-серверного запроса.
                    def add_cors(response: Response):
                        response.headers['Access-Control-Allow-Origin'] = 'https://www.google.com'  # Указывает хосты, которым разрешено делать запросы на backend, можно указать "*" для всех, но очень опасно.
                        # ['Access-Control-Allow-Methods'] - Указывает список методов, которые проходят CORS
                        # ['Access-Control-Allow-Headers'] - Указывает список хедеров, которые проходят CORS
                        # ['Access-Control-Max-Age'] - Указывает время кэширования информации браузером с прошлых двух хедеров # noqa
                        return response
                """,
            "cors_flask": r""" pip install flask_cors
                    app = Flask(__name__)

                    flask_cors.cross_origin(  # Настройка опций # noqa
                        origins='*',
                        methods=['GET', 'HEAD', 'POST', 'OPTIONS', 'PUT'],
                        headers=None,
                        supports_credentials=False,
                        max_age=None,
                        send_wildcard=True,
                        always_send=True,
                        automatic_options=False
                    )
                    CORS(app)  # Чтобы включить CORS для всех доменов на всех маршрутах, инициализируйте расширение Flask-Cors с параметрами по умолчанию. # noqa

                    @app.route("/")
                    @cross_origin()  # Просто добавьте @cross_origin() под маршрутом вызова в @app Flask. маршрут(..), чтобы разрешить CORS на данном маршруте. При CORS(app) - не нужен # noqa
                    def hello_world():
                        return "Hello world!"
                """
        },  # CORS - Проблема доступа между разными адресами. # noqa
        "CSRF": {
            "info": r"""
                    Например: можно авторизоваться от лица пользователя и делать все что, угодно от его лица.
                    Защита: При каждом запуске сессии выдается рандомный токен, далее при каждом действии токен проверяется на совпадение. Если токен
                        пользователя и сервера не совпадает, значит эту сессию скопировали и действия не исполнятся.
                """,
            "csrf_flask": r""" CSRF защита в Flask приложении (по умолчанию использует файл: SECRET_KEY):
                    1) Установка CSRF в приложении:
                        from flask_wtf.csrf import CSRFProtect, CSRFError
                        а.1) Классическая загрузка: 
                            csrf = CSRFProtect(app)

                        а.2) Ленивая загрузка: 
                            csrf = CSRFProtect()

                            def create_app():
                                app = Flask(__name__)
                                csrf.init_app(app)

                        б) Если проверка не удалась, будет выдан файл CSRFError. По умолчанию возвращает код 400, можно обработать вот так:
                            @app.errorhandler(CSRFError)
                            def handle_csrf_error(e):
                                return render_template('csrf_error.html', reason=e.description), 400

                        в.1) При необходимости можно отключить некоторые представления с помощью декоратора:
                        # Так же вы можете исключить все виды схемы элементов: csrf.exempt(account_blueprint)
                            @app.route('/foo', methods=('GET', 'POST'))
                            @csrf.exempt
                            def my_handler():
                                # ...
                                return 'ok'

                        в.2) Вы можете отключить защиту CSRF во всех представлениях по умолчанию:
                            - Установить WTF_CSRF_CHECK_DEFAULT значение False
                            - Там, где не нужно отключать защиту - можно выборочно вызывать protect() только тогда, когда вам нужно. Также 
                            позволяет вам выполнить некоторую предварительную обработку запросов перед проверкой токена CSRF:
                                @app.before_request
                                def check_csrf():
                                    if not is_oauth(request):
                                        csrf.protect()

                    2) Взаимодействие с HTML-кодом:
                        а) При использовании FlaskForm визуализируйте поле CSRF формы как обычно:
                            <form method="post">
                                {{ form.csrf_token }}
                            </form>

                        б) Если в шаблоне не используется FlaskForm, отобразите скрытый ввод с помощью токена в форме:
                            <form method="post">
                                <input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>
                            </form>
                """,
            "csrf_django": r""" CSRF защита в Django приложении:
                    1) Установка CSRF в приложении:
                        а) 'django.middleware.csrf.CsrfViewMiddleware' - Оно должно быть первым среди всех настроек CSRF.
                        б.1) Включить отдельные варианты можно с помощью csrf_protect():
                            from django.shortcuts import render
                            from django.views.decorators.csrf import csrf_protect

                            @csrf_protect
                            def my_view(request):
                                c = {}
                                # ...
                                return render(request, "a_template.html", c)

                        б.2) Кэширование отдельных вариантов с помощью cache_page():        
                            from django.views.decorators.cache import cache_page
                            from django.views.decorators.csrf import csrf_protect

                            @cache_page(60 * 15)
                            @csrf_protect
                            def my_view(request):
                                ...

                        б.3) Тестирование CSRF:
                            from django.test import Client
                            csrf_client = Client(enforce_csrf_checks=True)

                        в) Если запрос был отклонен, не прошел проверки, выполненные CsrfViewMiddleware или если CSRF-токен 
                        не был включен в форму POST - пользователю отправляется ответ «403 Forbidden». Что бы представить собственную 
                        обработку условия - установите CSRF_FAILURE_VIEW настройку. Сбои CSRF регистрируются в django.security.csrf, но 
                        в более старых версиях в django.request журнале.

                    2) Взаимодействие с HTML:
                        а) Для внутренних URL-адресов с формой POST(НЕ внешних, поскольку это приведет к утечке токена CSRF) нужно использовать csrf_token тег внутри <form> элемента. Например:
                            <form method="post">{% csrf_token %}

                        б) В соответствующих функциях просмотра использовать RequestContext для рендеринга ответа. Если используются функции, общие представления или доп. приложения, то защита уже 
                        включена, т.к. все они используют: {% csrf_token %} render() RequestContext.

                        в) При использовании CSRF токена в запросе Jinja2, который добавляет контекст всех шаблонов, что эквивалентно языку шаблонов Django. Например: {{ csrf_input }}{% csrf_token %}.
                            Пример реализации: <form method="post">{{ csrf_input }}

                        г) Для POST JavaScript(AJAX) запросов для каждого XMLHttpRequest установите собственный X-CSRFToken заголовок в значение токена CSRF.
                            - Для этого сначала нужно получить токен CSRF:
                                - Если CSRF_USE_SESSIONS = True:
                                    - Нужно включить CSRF токен в свой HTML и прочитать токен из DOM с помощью JavaScript:
                                        {% csrf_token %}
                                        <script type="text/javascript">
                                        // using jQuery
                                        var csrftoken = jQuery("[name=csrfmiddlewaretoken]").val();
                                        </script>
                                    - При установке токена в запросе AJAX нужно будет установить заголовок вашего запроса AJAX, защищая токен CSRF от отправки в другие домены с помощью settings.crossDomain.
                                        Если вы используете AngularJS 1.1.3 и новее, достаточно настроить провайдера $httpс именами файлов cookie и заголовков:
                                            $httpProvider.defaults.xsrfCookieName = 'csrftoken';
                                            $httpProvider.defaults.xsrfHeaderName = 'X-CSRFToken';
                                - Если CSRF_USE_SESSIONS = False:
                                    - Источником токена является файл cookie - 'csrftoken' по умолчанию, изменить это можно с помощью: CSRF_COOKIE_NAME настройки.
                                    - Для имени заголовка используется - 'HTTP_X_CSRFTOKEN' по умолчанию, изменить это можно с помощью: CSRF_HEADER_NAME настройки.
                                    # Токен CSRF также присутствует в DOM, но только если он явно включен csrf_tokenв шаблон.
                                    # С использованием библиотеки 'JavaScript Cookie' получить токен можно так: var csrftoken = Cookies.get('csrftoken');
                                    # Если ваше представление не отображает шаблон, содержащий csrf_token тег шаблона, Django может не установить файл cookie токена CSRF. Это часто 
                                    встречается в случаях, когда формы динамически добавляются на страницу. Чтобы решить эту проблему, Django предоставляет декоратор представления, который 
                                    принудительно устанавливает файл cookie: ensure_csrf_cookie().
                """,
        },  # CSRF - Возможность выполнить самые разные действия как от лица пользователя, так и от лица сервера. # noqa
        "JWT": {
            "info": r""" Токен состоит из 3 частей: заголовок(header), набор полей(payload), сигнатура.
                    Принцип работы JWT токена примерно как у SSH:
                        1) Создается токен, шифруется секретным ключом и отправляется пользователю.
                        2) Браузер сохраняет его себе.
                        3) При каждом запросе браузер кидает публичный токен, а на сервере он уже проверяется на валидность.
                """,
            "jwt": r"""
                    Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Третий блок же является шифрованием всего. Примеры:
                        1) Заголовок(декодированный) - header: {alg: "HS256", typ: "JWT"}. Оба поля обязательные и фиксированные. alg может принять шифровку RS256, он ассиметричный и создает 
                            2 ключа: публичный и приватный. С помощью приватного создается подпись, а с помощью публичного она проверяется. Для HS256 же нужен 1 секретный ключ, по 
                            которому и будет проверяться подлинность токена.
                        2) Набор полей(декодированный) - payload: {iss: "auth.myservice.com", aud: "myservice.com", exp: 1435937883, userName: "John Smith", userRole: "Admin"}. Тут 
                            есть поля с логикой самого приложения(свои передаваемые данные). Этот блок так же может содержать уже забинденные 
                            аргументы: iss - издатель токена, sub - тема токена, exp - время жизни токена, aud - получатель токена, nbf - срок, до которого токен не действителен, iat - время издания токена, 
                            jti - ид токена. Этот блок не шифруется при использовании токена, поэтому не стоит тут передавать персональные данные.
                        3) Сигнатура: S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY. Кодируется вместе с другой информацией, трогать не нужно.
                    В результате полного строения всех частей токена он начинает строиться: Алгоритм base64url кодирует блок 1(header) и блок 2(payload), после чего алгоритм соединяет все части через точку и 
                    затем полученная строка хэшируется выбранным алгоритмом шифрования в header(В данном случае HS256) на основе уже созданного секретного ключа. В итоге токен состоит из 3 рандомных строк, 
                    соединенных точками.

                    Создание сессии/токенов (api/auth/login):
                        1) Пользователь логинится в приложении, передавая логин/пароль и fingerprint браузера (ну или некий иной уникальный идентификатор устройства если это не браузер)
                        2) Сервер проверят подлинность логина/пароля
                        3) В случае удачи создает и записывает сессию в БД { userId: uuid, refreshToken: uuid, expiresIn: int, fingerprint: string, ... }
                            При успехе создаются access token и refresh token. Каждый токен имеет свой срок жизни, например access: 30 мин, refresh: 60 дней.
                            а) access token - используется для авторизации запросов и хранения дополнительной информации о пользователе (аля user_id, user_role или еще 
                                что либо, эту информацию также называет payload). Все поля в payload это свободный набор полей необходимый для реализации вашей частной бизнес логики.
                                Сам токен храним не в localStorage как это обычно делают, а в памяти клиентского приложения.
                            б) refresh token - выдается сервером по результам успешной аутентификации и используется для получения новой пары access/refresh токенов. Храним исключительно в httpOnly куке.
                                т.е. если acess токен просрут, refresh будет использован для смены токенов: создание нового acess и refresh токенов. Рефреш на сервере хранится в БД для учета 
                                доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах.

                                - Для того что бы refreshToken кука была успешно уставленна и отправлена браузером, адреса эндпоинтов 
                                аутентификации(/api/auth/login, /api/auth/refresh-tokens, /api/auth/logout) должны располагася в доменном пространстве сайта. Тоесть для домена super.com на 
                                сервере ставим куку с такими опциями: 
                                    {
                                        domain: '.super.com',
                                        path: '/api/auth'
                                    }
                                Таким образом кука установится в браузер и прийдет на все эндпоинты по адресу super.com/api/auth/<any-path>

                                - Если за аутентификацию отвечает отдельный микросервис, прячем его средствами nginx по выше указанному пути (super.com/api/auth).
                                # пример настройки nginx конфига(только основые настройки)
                                server {
                                    listen 80;
                                    server_name super.com;
                                    # SPA/Front-end
                                    location / {
                                        try_files $uri /index.html;
                                        root /var/www/frontend/dist;
                                        index index.html;
                                    }
                                    # Main API
                                    location /api {
                                        proxy_pass http://111.111.111.111:7000;
                                    }
                                    # Auth API
                                    location /api/auth {
                                        proxy_redirect http://222.222.222.222:7000   /auth/;
                                        proxy_pass http://222.222.222.222:7000;
                                    }
                                }
                                Когда создан секретный ключ со стороны пользователя, он отправляется в приложение, где сохраняется на будущее. В будущем благодаря тому, что секретный ключ 
                                есть и у пользователя и у приложения - JWT токен будет проверяться на валидность по этим ключам.

                        4) Отправляет клиенту access и refresh token uuid (взятый из выше созданной сессии), пример:
                            Set-Cookie: refreshToken='c84f18a2-c6c7-4850-be15-93f9cbaef3b3'; HttpOnly // для браузера
                            {
                              body: { 
                                accessToken: 'eyJhbGciOiJIUzUxMiIsI...',
                                refreshToken: 'c84f18a2-c6c7-4850-be15-93f9cbaef3b3' // для мобильных приложений
                              }
                            }
                        5) Клиент сохраняет токены(access в памяти приложения, refresh сетится как кука автоматом).
                """  # noqa
        },  # JWT - Возможность выполнить самые разные действия как от лица пользователя, так и от лица сервера. # noqa
    }  # Все, что касается безопасности приложений.

    request_codes = {
        "100": "Informational (информационные) коды ответа сервера",
        "100 Continue": "сервер удовлетворён начальными сведениями о запросе, клиент может продолжать пересылать заголовки",  # noqa
        "101 Switching Protocols": """сервер выполняет требование клиента и переключает протоколы в соответствии с указанием, данным в поле заголовка Upgrade.
                Сервер отправляет заголовок ответа Upgrade, указывая протокол, на который он переключился""",  # noqa

        "102 Processing": """запрос принят, но на его обработку понадобится длительное время. Используется сервером, чтобы клиент не разорвал соединение из-за 
                превышения времени ожидания. Клиент при получении такого ответа должен сбросить таймер и дожидаться следующей команды в обычном режиме""",  # noqa

        "103 Early Hints": "используется для раннего возврата части заголовков, когда заголовки полного ответа не могут быть быстро сформированы",  # noqa

        "200": "Success (успешно) коды ответа сервера",
        "200 OK": "это ответ на успешные GET, PUT, PATCH или DELETE. Этот код также используется для POST, который не приводит к созданию",  # noqa
        "201 Created": "этот код состояния является ответом на POST, который приводит к созданию",
        "204 Нет содержимого": "Это ответ на успешный запрос, который не будет возвращать тело (например, запрос DELETE)",  # noqa

        "300": "Redirection (перенаправление) коды ответа сервера",
        "301 Moved Permanently": "запрошенный документ был окончательно перенесен на новый URI, указанный в поле Location заголовка",  # noqa
        "302 Moved Temporarily": "запрошенный документ временно доступен по другому URI, указанному в заголовке в поле Location",  # noqa
        "304 Not Modified": "используйте этот код состояния, когда заголовки HTTP-кеширования находятся в работе",  # noqa

        "400": "Client Error (ошибка клиента) коды ответа сервера",
        "400 Bad Request": "этот код состояния указывает, что запрос искажен, например, если тело не может быть проанализировано",  # noqa
        "401 Unauthorized": "Если не указаны или недействительны данные аутентификации. Также полезно активировать всплывающее окно auth, если приложение используется из браузера",  # noqa
        "403 Forbidden": "когда аутентификация прошла успешно, но аутентифицированный пользователь не имеет доступа к ресурсу",  # noqa
        "404 Not found": "если запрашивается несуществующий ресурс",
        "405 Method Not Allowed": "когда запрашивается HTTP-метод, который не разрешен для аутентифицированного пользователя",  # noqa
        "410 Gone": "этот код состояния указывает, что ресурс в этой конечной точке больше не доступен. Полезно в качестве защитного ответа для старых версий API",  # noqa
        "415 Unsupported Media Type": "Если в качестве части запроса был указан неправильный тип содержимого",
        "422 Unprocessable Entity": "используется для проверки ошибок",  # noqa
        "429 Too Many Requests": "когда запрос отклоняется из-за ограничения скорости",

        "500": "Server Error (ошибка сервера) коды ответа сервера",
        "500 Internal Server Error": "любая внутренняя ошибка сервера, которая не входит в рамки остальных ошибок класса",  # noqa
    }  # Основные статус коды запросов к серверу. # noqa

    request_methods = {
        "HEAD": "Тоже, что и GET, но возвращает ответ без тела ресурса. Применяется обычно, чтобы проверить существование ресурса",  # noqa
        "PUT": "Используется для отправки пользовательских данных на указанный URL. Является идемпотентным. Полностью заменяет объект.",
        "PATCH": "Тоже, что и PUT, но изменяет только часть ресурса. Обновляет существующий объект.",
        "OPTIONS": "Используется для выяснения параметров соединения к конкретному ресурсу",
        "DELETE": "Используется, что бы удалить определенный ресурс",
        "POST": "Используется для отправки сложных или больших данных, а так для создания или обработки какой либо информации",
        "GET": "Используется для подачи небольших данных в виде 'my_url/?name=mitya&age=13'..."  # noqa
    }  # Основные методы запросов к серверу. # noqa

    api_zrelosti = {  # info ключи - это просто комментарии с объяснением # noqa
        "info1": "Структура API: contract реализуется в Postman: Нужно зайти в collections -> создать папку для API, внутри которой будет 4 уровня зрелости API",  # noqa
        "info2": "Создание WEB API: Может идти двумя путями, 1) code first - сперва делается код для API. 2) contract first - сперва генерируется контракт к API",  # noqa
        'level_0': {
            "info1": "1 lvl зрелости. Тут используется один метод(например POST), Использует только 1 протокол HTTP для взаимодействия. 1 URL.",  # noqa
            "info2": "Получение информации.  В теле запроса обязательно должна быть процедура, которая вызовется на сервере. 'target': 'open_slots'.",  # noqa
            "info3": "Запись информации. В теле запроса уже будет другая процедура (target). Вернуться может почти все, например dict в обоих запросах.",  # noqa
            'GET_slots': 'POST запрос',
            'MAKE_slots': 'POST запрос'
        },
        'level_1': {
            "info1": "2 lvl зрелости. Добавляется сам ресурс, для действий с этим ресурсом используется его URL. Много URL для описания разных ресурсов.",  # noqa
            "info2": "Отправляем данные уже на endpoint ресурса. Возвращает результат вместе с уникальным ид, на который можно будет сослаться в level_2.",  # noqa
            "info3": "Тут уже другой эндпоинт вместе с: /полученный_уникальный_ид, на который отправляются новые следующие данные. Получаем почти тоже самое",  # noqa
            'GET_slots': 'POST запрос',
            'MAKE_slots': 'POST запрос'
        },
        'level_2': {
            "info1": "3 lvl зрелости. Содержит так же много URL, но уже имеет множество методов запросов для описания взаимодействия с этими ресурсами.",  # noqa
            'GET_slots': 'GET запрос',
            'MAKE_slots': 'INSERT запрос'
        },
        'level_3': {
            "info1": "4 lvl зрелости. Может отправлять данные и указывать действия с ними. Тут ресурсы сами описывают себя, свои возможности и как с ними взаимодействует клиент.",  # noqa
            'GET_slots': 'GET запрос',
            'MAKE_slots': 'INSERT запрос'
        }
    }  # Уровни зрелости API. # noqa

    jinja2 = {
        "info": """ Тут описан язык разметки Jinja2, а точнее его основные моменты; pip install Jinja2 - Установит язык разметки.
            Пример использования:
            tm = Template("Привет, {{ name }}")  # Шаблон поддерживает функции Python, например: 'name.lower()' или 'name*2'. Вывод: 'Привет, Коля'. # noqa
            msg = tm.render(name=name)  # Так подставляются переменные, классика Python. msg = 'Привет, Коля'. # noqa
        """,  # Основная информация и синтаксис. # noqa
        "loading": {
            "pattern": """
                load_obj = FileSystemLoader("folder")  # Папка, в которой лежат HTML шаблоны. "" - активная папка.
                env = Environment(loader=load_obj)  # Загружает папку с шаблонами.
                tm = env.get_template("main.htm")  # Загружает конкретный файл из папки с шаблонами.
                msg = tm.render(name=name)  # Обработка шаблона с вставкой данных.
            """,  # Показано как производить саму загрузку.
            "Загрузка шаблона из файла": FileSystemLoader,  # noqa
            "Загрузка шаблона из пакета": PackageLoader,  # noqa
            "Загрузка шаблона из словаря": DictLoader,  # noqa
            "Загрузка шаблона из функции": FunctionLoader,  # noqa
            "Словарь для подкаталогов с шаблонами": PrefixLoader,  # noqa
            "Загрузка шаблона из списка": ChoiceLoader,  # noqa
            "Загрузка скомпилированных шаблонов из модулей.": ModuleLoader,  # noqa
        },  # Как загружать шаблоны из разных источников. # noqa
        "params": {  # %- или -% убирают перенос строки до и после, если он используется.
            "---------- Переменные для примеров ----------": "---------- Переменные для примеров ----------",
            "name": "kolya",
            "link": '<a href="#">Ссылка</a>',
            "elements": '["first", "second", "third", "fourth"]',
            "auto": '[{"car": "first", "price": 1500}, {"car": "second", "price": 1200}]',
            "---------- Шаблонные параметры ----------": "---------- Шаблонные параметры ----------",
            "Вставка": "{{ name }}",  # Так можно вставить переменные в шаблон для отображения результата. # noqa
            "Экранирование": "{{ link | e }} ИЛИ в коде: tm = escape(link)",  # Выведет: '&lt;a href=&#34;#&#34;&gt;Ссылка&lt;/a&gt;'. # noqa
            "Jinja функции": "{{ auto | sum(attribute='price') }}",  # Выведет суммарную стоимость автомобилей. Функции искать в документации. # noqa
            "Обычный комментарий": "{# Комментарий #}",  # Так вставляются данные, которые будут в HTML структуре, но не будут отображаться визуально. # noqa
            "Строковый комментарий": "### Комментарий",  # Вставка комментариев. То же самое, но распространяется на строку. # noqa
            "SET": "{% set number = numbers[0] %}",  # Установка локальной переменной прямо в шаблоне. # noqa
            "FIRSTOF": "{% firstof value 'none' %}",  # Проверит значение, если его нет, то выведет результат в кавычках. # noqa
            "IF": """
                        {% if number == "first" -%}
                            <div>Условие верно</div>
                        {% endif -%}
                    """,  # Внутрення часть выполнится только при выполнении условия. Так же можно юзать {% else -%}. # noqa
            "FOR": """  # empty - указывает, что вывести, если список значений пустой.
                        {% for i in elements -%}
                            <div> i </div>
                        {% empty %}
                            <div> No elements </div>
                        {% endfor -%}
                    """,  # Задублирует внутреннюю часть с каждым элементом списка. Например: '<h1> i </h1>'. # noqa
            "RAW": """
                        {% raw %}
                            <div> Привет, {{name}} </div>
                        {% endraw %}
                    """,  # Игнорирование шаблонов. Внутренняя часть не изменится. Например: 'Привет, {{name}}' так и выведется. # noqa
            "FILTER": """
                        {% filter upper %}
                            <div> {{name}} </div>
                        {% endfilter %}
                    """,  # Применяет фильтры к внутренней части. Например: {{name}} будет большими буквами. # noqa
            "BLOCK": """ # Блок - по сути шаблон, который дальше можно будет переопределить, заменив какие то данные, например только переменные.
                        # Шаблон, выделенный кусок кода, с которым можно будет работать отдельно:
                            {% block title %}
                                <div>{{name}}</div>
                            {% endblock %}
                        # Замена, выделенный кусок кода, с которым можно будет работать отдельно:
                            {% block title %}
                                <div>{{username}}</div>
                            {% endblock %}
                        # {% block a scoped %}, scoped - позволяет брать данные за пределами блока, например переменные.
                    """,  # Вставка параметров, операторов... Блок можно переопределять в разных файлах под разную информацию. Вывод: <div>{{name}}</div>. # noqa
            "INCLUDE": """ # ignore missing - значит, что нужно игнорировать ошибки при отсутствии импортируемого файла.
                        {% include 'header.htm' ignore missing %}
                    """,  # Загрузка шаблона из другого файла (можно список). Загрузит header часть из другого файла. # noqa
            "EXTENDS": """ # Можно указать {{ self.title() }}, вернет содержимое: {% block title %}, и даже self.super().
                        {% extends 'file.htm' %}
                        {% block title %}О сайте{% endblock %}
                    """,  # Наследование. Возьмет содержимое из 'file.htm' и дополнит его указанными данными, заменяя переменные. # noqa
            "FROM": """
                        {% from 'file.htm' import macros_name as mcr %}
                        <div>{{mcr}}</div>
                    """,  # Импорт из файла. Позволяет ниже использовать сам импортируемый объект. Например макрос: '<div>{{mcr}}</div>'. # noqa
            "MACROS": """
                        {% macro input(name, value="", type="text", size=20) -%}
                            <input type="{{ type }}" name="{{ name }}" value="{{ value | e }}" size="{{ size }}">
                        {%- endmacro %}
                        <p>{{input('username')}}
                    """,  # Создает макрос, который можно будет дальше использовать. Вывод: '<input type='text' name='username' values='' size='20'>'. # noqa
            "DOUBLE MACROS": """
                        Основной макрос, который будет генерировать список:
                            {% macro list_auto(list_ot_auto) -%}
                            <ul>
                            {% for auto in list_ot_auto -%}
                                <li>{{auto.car}} {{caller(auto)}}
                            {%- endfor %}
                            </url>
                            {%- endmacro %}

                        Дополнительный вызываемый макрос, который будет вызываться в первом макросе и генерировать доп. данные:
                            {% call(auto) list_auto(autos) %}
                                <ul>
                                <li>age: {{auto.price}}
                                </ul>
                            {% endcall -%}
                    """,  # Пример вложенного макроса, выведет список, внутри которого еще список. Подается: tm.render(autos=auto). # noqa
        },  # Основная обобщенная информация. # noqa
    }  # Шаблоны Jinja2 и все, что с ними связано. # noqa

    web_server = {
        "info": "Для соединения Backend + Frontend, первый нужно запустить через спец. протокол (WSGI или ASGI), который обеспечивает их совместимость.",
        "WSGI": "Синхронный протокол. Установка: 'pip install gunicorn'. Запуск: 'gunicorn --bind 0.0.0.0:5000 routes:app'. DEBUG: '--reload'.",
        "ASGI": "Асинхронный протокол. Установка: 'pip install uvicorn'. Запуск: 'uvicorn routes:app --host 0.0.0.0 --port 5000'. DEBUG: '--reload'.",
    }  # Описано, как соединять Backend(Server) + Frontend(Client) части. # noqa


class FlaskApp:
    """ Тут расписана работа с framework Flask. """
    from typing import Optional  # Импорт для аннотации типов # noqa
    from flask import Flask, request, jsonify, Response  # pip install flask - Синхронный ||| pip install flask[async] - Асинхронный # noqa
    from werkzeug.exceptions import InternalServerError, Unauthorized  # Импорт для обработки ошибок # noqa

    app = Flask(__name__)

    def validation():  # Валидация обычно выносится в отдельный файл # noqa
        """ Тут расписан принцип валидации данных в Flask. """

        def wtforms():  # noqa
            """ Тут валидация через WTForms. Она не особо совместима с swagger'ом. """
            from flask_wtf import FlaskForm  # pip install flask_wtf - нужен для валидации параметров # noqa
            from wtforms import IntegerField, StringField, validators  # Импорт для валидации в приложении # noqa

            def join_swagger():  # noqa
                """ Тут показано как можно форму WTForms совместить со swagger'ом. pip install Swagger-Marshmallow-Codegen """
                from marshmallow_swagger import Schema as SwaggerSchema  # noqa
                from swagger_ui import api  # noqa

                swagger_user_schema = SwaggerSchema.from_schema(UserSchema)  # UserSchema - схема от WTForms # noqa

                @api.post('/users', schema=swagger_user_schema)  # Отдельный Endpoint-API.
                async def create_user(request):  # noqa
                    data = await request.json()
                    user_schema = UserSchema()  # noqa
                    errors = user_schema.validate(data)

                    if errors:
                        return {'message': 'Validation errors', 'errors': errors}, 400
                    return {'message': 'User created successfully'}

            def validate_email(form, field):
                """ Функция кастомной валидации данных, идентична для GET и POST запросов, разница лишь в подаче данных внутрь. """  # noqa
                email = form.data  # Вернет словарь со всеми значениями для валидации, например: {"email": "my_email"} # noqa
                email = field.data  # Вернет .values() значения для валидации, например: my_email # noqa

                if isinstance(email, int):
                    raise ValueError("message")

            class MyForm(FlaskForm):  # Класс для валидации данных (пример в GET и POST методе) # noqa
                email = StringField('email', validators=[validators.InputRequired(), validators.email(), validate_email])  # 'email' - имя переменной, поданной в запросе.
                phone = IntegerField('phone', validators=[validators.InputRequired(), validators.number_range(min=1000000000, max=9999999999)])
                elements = FieldList(IntegerField("list", validators=[validators.Optional()]))  # Так можно обработать входящий список от request.get_json(), его нужно подать в form.process # noqa

        def swagger_marshmallow():  # noqa
            """ Тут валидация через marshmallow + swagger. pip install flasgger==0.9.7b2, pip install marshmallow apispec, pip install -U setuptools """
            from flasgger import Schema, fields, ValidationError  # noqa
            from marshmallow import validates, post_load  # noqa

            class MyForm(Schema):  # Пример создания схемы на MarshMellow + Swagger. # noqa
                """ dump_only=True - проверяется только при сериализации в json формат, т.е. пользователь не должен вводить это поле. """  # noqa
                name = fields.Str(required=True, error_messages={"invalid": "Сообщение если в валидации required не выполнен."})
                age = fields.Int(required=True, error_messages={"invalid": "Сообщение если в валидации required не выполнен."})
                numbers = fields.List(fields.Int(required=True, error_messages={"invalid": "Сообщение если в валидации required не выполнен."}))

                @validates("name")  # Пример кастомной валидации параметра. # noqa
                def validate_name(self, name: str):
                    if name not in ["name1", "name2"]:
                        raise ValidationError("Имя не зарегистрировано.")

                @post_load  # То, что возвращает форма после валидации. data - валидируемые данные, поданные в схему в формате 'dict'. # noqa
                def returning_form(self, data: dict, **kwargs) -> dict:  # **kwargs - Данные самой схемы, например: 'many=True'. # noqa
                    return data  # Возвращает все то же самое, что и принимает вначале.

    def swagger():  # noqa
        """ Тут описано, как прикрутить swagger документацию к приложению Flask. Основной синтаксис:
        1) '---' - Таким образом происходит отделение комментария от документации swagger.
        2) '  ' - Два пробела, так отделяется сущность. Т.е. так отделяются дочерние элементы с новой строки.
        3) '- ' - Пример '- name:', таким образом помечаются элементы списка. """  # noqa
        from apispec.ext.marshmallow import MarshmallowPlugin  # pip install marshmallow apispec # noqa
        from apispec_webframeworks.flask import FlaskPlugin  # noqa
        from flasgger import Swagger, APISpec, swag_from  # pip install flasgger==0.9.7b2 # noqa

        parameters = {  # Тут указаны возможные параметры при составлении документации. В начале описание самого endpoint'а, оно тоже нужно.
            "tags": "Секция-список разделов в документации и деление endpoint'ов по этим разделам. Например раздел tweets, где все endpoint'ы для работы с твитами.",
            "post": "Секция для описания параметров POST метода запроса внутри секции. Соответственно есть и другие методы.",
            "parameters": "Секция для описания используемых данных в запросе. Например аргументы запроса: name='name'...",
            "responses": "Секция для описание возвращаемых данных. Тут описываются возможные ответы со своими статус кодами.",
            "201": "Секция для описания возвращаемого результата с кодом 201 (есть и другие коды). Внутри описываются детально параметры и все такое.",
            "schema": "Секция указывает схему валидации для параметра. Например: $ref: '#/definitions/TweetsPostForm'. Схемы: spec.to_flasgger(app, definitions=[схема1])",
            "properties": "Секция для описания параметров в самой схеме. Например: 'name:' его описание: 'type: string, description: bla-bla...'",
            "examples": "Секция описывает варианты return данных при конкретном параметре в запросе. Например: 'a: [...]'. Т.е. при выборе 'a' вернется список.",
            "externalDocs": "Секция описывает репозиторий. Тут может быть описание и ссылка (description, url).",
            "consumes": "Секция описывает список типов получаемого контента. Например: '- application/json'.",
            "produces": "Секция описывает список типов отдаваемого контента. Например: '- application/json'.",
            "security": "Секция описывает списка безопасности. Например: '- ApiKeyAuth: []', ApiKeyAuth - описанная модель в 'securitySchemes' секции.",
            "components": "Секция описывает доп. элементы. Например: 'securitySchemes' секцию для защиты.",
            "securitySchemes": "Секция описывает механизмы защиты. Например: 'ApiKeyAuth' секцию.",
            "definitions": "Секция описывает схемы. Например можно описать схему возвращаемых данных.",
            "name": "Параметр указывает название используемого аргумента в запросе. Например: 'name: api-key', api-key - аргумент запроса из header.",
            "enum": "Параметр указывает список возможных значений для этого аргумента. Например: ['a', 'b']. Параметр может быть только 'a' или 'b'.",
            "default": "Параметр указывает значение по умолчанию. Например: 'default: a'. То есть, если параметр не указан, то будет использоваться 'a'.",
            "in": "Параметр указывает расположение аргумента в запросе. Например: body, headers, url, cookie, query, path или как-то еще.",
            "type": "Параметр указывает тип аргумента в запросе. Например: array, string, integer...",
            "required": "Параметр указывает необходимость аргумента в запросе. Например: true - если параметр обязательный, false - если нет.",
            "description": "Параметр указывает краткое описание элемента. Например для api-key: ключ для авторизации пользователя в приложении.",
            "x-apikeyInfoFunc": "Параметр указывает функцию, которая проверяет валидность ApiKey. Например: ': app.my_func'.",
        }

        tweets_get_yml = """ Документация может быть как в отдельных файлах, так и прямо в внутри Endpoint'а, как его описание.
                Endpoint получения списка твитов пользователя.
                ---
                tags:
                  - tweets
                get:
                  parameters:
                    - name: api-key
                      in: header
                      type: string
                      required: true
                      description: Ключ для авторизации пользователя.
                definitions:
                  TweetsGet:
                    type: object
                    properties:
                      result:
                        type: boolean
                      tweets:
                        type: object
                        schema:
                          $ref: '#/definitions/Tweet'
                  Tweet:
                    type: object
                    properties:
                      id:
                        type: integer
                      content:
                        type: string
                      attachments:
                        type: array
                      author:
                        type: object
                      likes:
                        type: array
                  Error:
                    type: object
                    properties:
                      result:
                        type: boolean
                      error_type:
                        type: string
                      error_message:
                        type: string
                responses:
                  200:
                    description: Возвращает список твитов пользователя при GET запросе.
                    schema:
                      $ref: '#/definitions/TweetsGet'
                  400:
                    description: Возвращает информацию об операции при ошибке.
                    type: object
                    schema:
                      $ref: '#/definitions/Error'
                  401:
                    description: Возвращает информацию об операции при ошибке авторизации.
                    type: object
                    schema:
                      $ref: '#/definitions/Error'
                """  # noqa

        tweets_post_yml = """ Схемы можно описывать как в коде 'schemas.py', так и в документации в секции 'definitions'.
                Endpoint для создания нового твита.
                ---
                tags:
                  - tweets
                post:
                  parameters:
                    - name: api-key
                      in: header
                      type: string
                      required: true
                      description: Ключ для авторизации пользователя.
                    - name: data
                      in: body
                      type: object
                      required: true
                      description: Содержимое твита для добавления в БД.
                      schema:
                        $ref: '#/definitions/TweetsPostForm'
                definitions:
                  Post:
                    type: object
                    properties:
                      result:
                        type: boolean
                      tweet_id:
                        type: integer
                  Error:
                    type: object
                    properties:
                      result:
                        type: boolean
                      error_type:
                        type: string
                      error_message:
                        type: string
                responses:
                  201:
                    description: Возвращает при успешном создании твита при POST запросе.
                    type: object
                    schema:
                      $ref: '#/definitions/Post'
                  400:
                    description: Возвращает информацию об операции при ошибке.
                    type: object
                    schema:
                      $ref: '#/definitions/Error'
                  401:
                    description: Возвращает информацию об операции при ошибке авторизации.
                    type: object
                    schema:
                      $ref: '#/definitions/Error'
                """  # noqa

        security = """ Тут пример как описать защиту.
                securityDefinitions:  # Раздел, где описываются схемы защиты
                  ApiKeyAuth:  # Имя схемы защиты.
                    type: apiKey  # Тип защиты
                    in: header  # Где подается ключ.
                    name: X-API-Key  # Имя ключа защиты.

                paths:  # Пути, к которым нужно добавить защиту
                  /example:
                    get:  # Метод, который защищен.
                      security:  # Тут указана схема защиты, описанная выше.
                        - ApiKeyAuth: []
                      description: Описание вашего эндпоинта
                      responses:
                        200:
                          description: Успешный ответ
                """  # noqa

        @app.route("/api/tweets", methods=["GET", "POST"], endpoint="first")  # Endpoint для примера описания документации. # noqa
        @swag_from("./docs/tweets_get.yml", methods=["GET"], endpoint="first")  # Импортированная документация из файла.
        @swag_from("./docs/tweets_post.yml", methods=["POST"], endpoint="first")  # Можно и по Endpoint'ам настраивать.
        async def tweets() -> [Response, int]:  # User - Модель таблицы из базы данных с методами работы с ней. # noqa
            user: [User, bool] = User.get_user(api_key=request.headers.get("api-key"))  # noqa

            if request.method == "POST":  # noqa
                form: TweetsPostForm = TweetsPostForm()  # noqa
                data: dict = request.get_json()  # noqa
                valid_data: dict = form.load(data)

                tweet_id: [int, bool] = Tweet.add(  # noqa
                    user=user,
                    data=valid_data["tweet_data"],
                    medias=valid_data["tweet_media_ids"]
                )

                if tweet_id:
                    return jsonify({"result": True, "tweet_id": tweet_id}), 201  # noqa
                else:
                    raise ValueError("Не удалось создать твит.")

            elif request.method == "GET":  # noqa
                if len(user.tweets) > 0:
                    result: list = list()

                    for tweet in user.tweets:
                        result.append({
                            "id:": tweet.id,
                            "content": tweet.tweet_data,
                            "attachments": tweet.medias,
                            "author": {"id": user.id, "name": user.name},
                            "likes": [
                                {"user_id": u.id, "name": u.name} for u in tweet.tweet_likes
                            ],
                        })
                else:
                    result: list = list()

                return jsonify({"result": True, "tweets": result}), 200  # noqa

            else:
                raise MethodNotAllowed("Method not allowed")  # noqa

        spec = APISpec(
            title='Twitter',  # Имя API документации
            version='1.0.0',  # Версия API документации
            openapi_version='2.0',  # Версия интерфейса API документации (может вызывать ошибки в видимости схем)
            plugins=[  # Вспомогательные плагины
                FlaskPlugin(),  # С ним можно добавить все эндпоинты в документацию # noqa
                MarshmallowPlugin()  # Помогает аннотировать возвращаемые модели # noqa
            ]
        )

        template = spec.to_flasgger(app, definitions=[TweetsPostForm, MediasPostForm, IdForm])  # Тут перечисляются формы валидации swagger+marshmallow # noqa
        swagger = Swagger(app, template=template)  # Подключение самой API и загрузка настроек. Схемы искать в функции 'validation', так же их можно описывать в docs. # noqa
        return parameters, tweets_get_yml, tweets_post_yml, security

    def support_endpoints():  # noqa
        """ Тут показано создание вспомогательных endpoint'ов. """

        @app.before_request  # Handler, который выполняется перед каждым запросом, тут может быть авторизация.  # noqa
        async def before() -> [Response, int]:  # noqa
            response = await User.get_user(...)  # noqa

            if not response:
                return jsonify({"result": False, "error_type": Unauthorized().name, "error_message": Unauthorized().description}), 401  # noqa

        @app.after_request  # Handler, который выполняется после каждого запроса перед отправкой данных, тут может быть настройка csp защиты.  # noqa
        async def after(response: Response) -> Response:  # CSP защита для примера.  # noqa
            response.headers['Content-Security-Policy'] = "default-src 'self'"  # Сообщает браузеру, откуда он может загружать различные типы ресурсов(self - от себя). # noqa
            response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'  # Запрещает злоумышленнику подключаться между сервером и клиентом. # noqa
            response.headers['X-Content-Type-Options'] = 'nosniff'  # Браузер учитывает тип содержимого ответа вместо обнаружения (XSS защита) # noqa
            response.headers['X-Frame-Options'] = 'SAMEORIGIN'  # Запрещает внешним сайтам встраивать сайт в iframe. # noqa
            return response

        @app.errorhandler(InternalServerError)  # Универсальный Handler для обработки ошибок с 500 кодом InternalServerError # noqa
        async def errorhandler(e: InternalServerError):  # noqa
            original: Optional[Exception] = getattr(e, 'original exception', None)  # noqa

            if isinstance(original, FileNotFoundError):
                return f'Файл: {original.filename}, ошибка: {original.strerror}', 400

    @app.route("/page/<int:a>/<float:b>/<path:c>", methods=["GET", "POST"])  # Базовый Endpoint для примера работы.
    async def handler(a: int, b: float, c: str) -> Response:  # noqa
        if request.method == "GET":  # noqa
            """ Метод 'GET' обычно используется для запроса и чтения каких либо данных. email, phone - обработка GET запроса вида '?email=bla&phone=blabla'.
            jsonify обеспечивает доп. безопасность для возвращаемого объекта, так же переводит Python словарь в JSON ответ формата 'Response'. """
            email: str = request.args.get('email', type=str)  # Получение данных формата GET: ?email=bla&...  # noqa

            form = MyForm(request.args)  # Валидация данных через соответствующий класс. # noqa
            if form.validate():  # Вернет True при успешной GET валидации.
                return jsonify({"a": form.email.data})  # Получение данных из формы валидации.  # noqa
            return jsonify({"a": a, "b": b, "c": c, "email": email})  # noqa

        elif request.method == "POST":  # noqa
            """ POST метод обычно используется для создания записей или передачи самой разной информации: файлы, текстовая информация и т.д. Не является 
            идемпотентным (т.е. не кэшируется: повторный запрос не дает кэшированную информацию) Данные могут подаваться самыми разными способами.
            form используется для валидации данных, которая настраивается в одноименном классе 'PostForm'. """
            email = request.form.get("email")  # Получение данных по 'form-data' или 'urlencoded' # noqa
            email = request.get_data().decode()  # Получение данных по 'raw', возвращает {"email": "my_email"} как строковое значение. # noqa
            email = request.get_json()  # Получение данных по 'raw', возвращает {"email": "my_email"} как словарь # noqa

            form = MyForm()  # Валидация данных через соответствующий класс. # noqa
            if form.validate_on_submit():  # Вернет True при успешной POST валидации.
                return jsonify({"a": form.email.data, "b": form.phone.data})  # Получение данных из формы валидации  # noqa
            return jsonify(form.errors)  # return: {'phone': ['Not a valid integer value.']} # noqa

    def blueprints():  # noqa
        """ Тут описано, как создать blueprint в приложении на Flask. Он хорошо подходит для админ панели. """
        from .admin.admin import admin  # Импорт по пути: /admin/admin.py забираем из файла admin (подробнее в admin.py можно глянуть) # noqa

        app.register_blueprint(admin, url_prefix='/admin')  # app - основное приложение. admin - импортируемый blueprint из файла admin.py # noqa

        def admin_py():  # noqa
            """ Файл: admin.py, для примера реализации blueprint. """
            from flask import Blueprint  # noqa

            admin = Blueprint('admin', __name__, template_folder='templates', static_folder='static')

            @admin.route('/')
            def index():
                return "admin"

    if __name__ == "__main__":
        app.config["WTF_CSRF_ENABLED"]: bool = False  # параметр, обеспечивающий доп. защиту # noqa
        app.config['UPLOAD_FOLDER']: str = "/static/images"  # Папка для загруженных файлов, обязательная настройка для работы с файлами из Flask(есть и другие настройки).
        app.run(debug=True, host="0.0.0.0", port=80)  # 80 - Порт отвечает за передачу HTTP протокола ||| 443 - Порт отвечает за передачу HTTPS протокола # noqa

    def flask_json_rpc(self):  # noqa
        """ Тут пример реализации JSON-RPC API на приложении Flask """
        # Для json API: headers: {'Accept': 'application/vnd.api+json', 'Content-Type': 'application/vnd.api+json'}
        # более мелкое API: JSON-RPC: имеет всего 1 endpoint, работает по JSON API.
        from flask_jsonrpc import JSONRPC  # noqa
        from flask import Flask  # noqa

        app = Flask(__name__)  # noqa
        jsonrpc = JSONRPC(app, '/api', enable_web_browsable_api=True)

        @jsonrpc.method('method_name')  # noqa
        def add(self, a: int, b: int) -> int:  # noqa
            return a + b

        request_cmd = r"""
            curl -i -X POST -H "Content-Type: application/json; indent=4" \
                -d '{
                    "jsonrpc": "2.0",
                    "method": "method_name",
                    "params": {"a": 7, "b": 5},
                    "id": "1"
                }' http://localhost:5000/api
            """
        return request_cmd


class FastAPIApp:
    """ Класс содержит информацию касательно FastAPI. Он имеет встроенную документацию, но ее нужно подкорректировать. """
    import uvicorn  # noqa
    from typing import List, Optional  # noqa
    from fastapi import FastAPI, Request, APIRouter, Depends, Path, Query, Body  # noqa
    from fastapi.middleware.cors import CORSMiddleware  # noqa

    @app.on_event("startup")  # Ловит ивент запуска приложения # noqa
    async def shutdown() -> None:  # noqa
        async with engine.begin() as conn:  # Создает движок для подключения к базе данных # noqa
            await conn.run_sync(AbstractModel.metadata.create_all)  # Запускает создание описанных таблиц # noqa

    @app.on_event("shutdown")  # Ловит завершение работы приложения # noqa
    async def shutdown() -> None:  # noqa
        await session.close()  # Закрывает сессию # noqa
        await engine.dispose()  # Ломает движок для подключения # noqa

    app = FastAPI(title="My application", version="1.0.0")
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
        allow_credentials=True,
    )

    @staticmethod
    async def validation():
        """ Пример схем валидации данных. Схемы в виде класса на библиотеке 'pydantic'. """
        from pydantic import BaseModel, Field  # noqa

        class RequestSchema(BaseModel):
            name: str = Field(min_length=4, max_length=30)  # Field - кастомные параметры для полей. В данном примере длина значения в поле 4-30 символов. # noqa

        class ResponseSchema(RequestSchema):  # Наследуем схему от другой схемы и получаем: 'id', 'name' поля сразу. # noqa
            id: int = Field(lt=1000)  # Field - кастомные параметры для полей. lt=1000 значит, что поле должно быть меньше 1000. # noqa

            class Config:
                orm_mode = True  # Говорим, что сюда поступают объекты из ORM SQLAlchemy, что бы схема понимала, как их обрабатывать. # noqa

    @staticmethod
    async def module():
        """ Пример отдельного модуля приложения. На пример сервис авторизации, после реализации он отдельно подключается к приложению. """
        module_router = APIRouter()  # Path - для параметров из url. Query - для одноименных параметров после знака '?'. Body - для параметров из тела запроса. # noqa

        @module_router.get("/schema/{endpoint}")  # noqa
        async def schema_endpoint(endpoint: int = Path(int, title="title", ge=0)):  # int можно не указываться, берется из аннотации. title - для документации. # noqa
            """ Пример строения endpoint'а с описанием схемы прямо в нем же. Пример Path параметра прямо из url. """
            return {"endpoint": endpoint}

        @module_router.get("/schema/get", response_model=List[ResponseSchema])  # Возвращаются данные формата 'ResponseSchema' в виде списка.  # noqa
        async def schema_get(data: RequestSchema, session: get_async_session = Depends()) -> List[ResponseSchema]:  # Поступают данные формата 'RequestSchema'.  # noqa
            """ Пример строения GET endpoint'а со схемой на классе. Пример Query параметра, из GET аргументов. """
            data["id"] = 1  # Типа делается запрос в базу данных и возвращается data из нее с новыми данными.
            return [data.dict() for _ in range(3)]  # Depends() вызывает другую функцию и передает в нее аргументы при необходимости прямо в параметрах.

        @module_router.post("/schema/post", response_model=List[ResponseSchema])  # Возвращаются данные формата 'ResponseSchema' в виде списка.  # noqa
        async def schema_post(data: RequestSchema, session: get_async_session = Depends()) -> List[ResponseSchema]:  # Поступают данные формата 'RequestSchema'.  # noqa
            """ Пример строения POST endpoint'а со схемой на классе. Пример Body параметров из тела запроса. """
            data["id"] = 1  # Типа делается запрос в базу данных и возвращается data из нее с новыми данными.
            return [data.dict() for _ in range(3)]  # Depends() вызывает другую функцию и передает в нее аргументы при необходимости прямо в параметрах.

    app.include_router(module_router, prefix="/module", tags=["Module"])  # Подключение отдельного router'а к приложению. # noqa

    if __name__ == "__main__":  # Запускать предпочтительнее консольной командой.
        uvicorn.run(app, host="0.0.0.0", port=8000)


class DjangoApp:
    """ В классе описана часть информация касательно Django. Большая часть информации в проекте 'django_site'. """
    django = {
        "info": """ 
            Инструкция настройки запускающей конфигурации Django проекта:
                1) Жмем Edit configuration вверху(где кнопка run/play).
                2) Жмем '+' слева наверху, что бы добавить конфигурацию.
                3) Далее заполняет информацию:
                    а) Name - имя конфигурации.
                    б) Working directory - корень проекта (это синяя папка, или та, в которой файл 'manage.py').
                    в) Python Interpreter - путь до python.exe включительно (основное окружение или venv).
                    г) Script path - путь до запускающего скрипта. В данном случае до файла 'manage.py' включительно.
                    д) Parameters - параметры, с которыми нужно запускать скрипт. Например runserver.

            Django при работе объединяет папки templates со всех приложений, поэтому внутри каждой templates надо создать доп. папку(например: myapp/templates/myapp).
            """,  # Универсальная информация. # noqa
        "structure": {
            "manage.py": "Главный управляемый файл приложения. С ним будет работа по запуску с различными параметрами.",
            "---------- Основная папка ----------": "---------- Основная папка ----------",  # В примере: 'django_site'.
            "settings.py": "Хранит в себе ВСЕ настройки приложения, включая все модули приложения.",  # noqa
            "sitemaps.py": "Хранит все краткие проводники по приложениям: нужные ссылки и описания к ним.",  # noqa
            "urls.py": "Список ссылок приложения, тут можно подключать модули или конкретные ссылки к приложению.",  # noqa
            "asgi.py": "Отдает application для запуска приложения. Асинхронный.",  # noqa
            "wsgi.py": "Отдает application для запуска приложения. Синхронный.",  # noqa
            "---------- Дополнительная папка ----------": "---------- Дополнительная папка ----------",  # В примере: 'myapp'.
            "fixtures/": "Хранит в себе все fixture для тестов приложения. Это например дамб БД.",
            "management/commands": "Хранит в себе команды кастомные команды Django. Название файла - будет названием команды.",
            "migrations/": "Хранятся файлы миграции БД.",  # noqa
            "templates/": "Хранит HTML шаблоны. В общем страницы проекта.",  # noqa
            "admin.py": "Указывает, какие модели БД нужно отображать в админке.",  # noqa
            "apps.py": "Конфигурация этого модуля.",  # noqa
            "forms.py": "Хранятся все обратные формы для этого приложения (<form> из HTML).",  # noqa
            "middlewares.py": "Меняется логика ДО и ПОСЛЕ запросов. По сути это: 'before_request', 'after_request'.",  # noqa
            "models.py": "Описываются модели БД для этого модуля.",  # noqa
            "serializers.py": "Описывает сериализаторы для конвертации данных в JSON... Нужен для REST Framework для отправки разных данных.",  # noqa
            "sitemap.py": "Хранит в себе краткий проводник по приложению: все его нужные ссылки и описания к ним.",  # noqa
            "tests.py": "Описываются тесты этого модуля. Django сам создает копию БД для тестов и после тестов удаляет ее.",  # noqa
            "urls.py": "Список ссылок приложения. Тоже, что в основном приложении, нужен, что-бы можно было подключать весь модуль сразу.",  # noqa
            "views.py": "Описываются функции для обработки запросов (endpoint'ы).",  # noqa
        },  # Тут описана основная структура проекта. # noqa
        "commands": {
            "python -m django startproject django_site": "Команда создаст в активной дирректории начальную структуру проекта с названием 'django_site'.",  # noqa
            "python manage.py startapp myapp": "Создает в активной директории начальную структуру приложения(типа отдельный модуль 'myapp': форум или основной сайт).",
            "python manage.py runserver": "Запустит созданный проект из файла manage.py.",
            "python manage.py createsuperuser": "Создание админа для сайта.",
            "python manage.py help": "Покажет все команды для запуска скрипта.",
            "python manage.py makemigrations": "Отвечает за создание новых миграций на основе изменений, внесенных в модели БД (типа commit).",  # noqa
            "python manage.py show migrations": "Перечисляет миграции проекта и их статус.",
            "python manage.py migrate": "Отвечает за применение и отмену миграции (применяет commit к БД). Можно так же указать имя модуля, к которому нужна миграция, и номер миграции.",
            "python manage.py sqlmigrate": "Отображает инструкции SQL для миграции.",
            "python manage.py test myapp.tests.SumFunctionTestCase": "Запуск конкретного теста и файла с тестами.",
            "python manage.py dumpdata myapp.Product > data.json": "Выгрузит в консоль содержимое БД из этого приложения. Можно не указывать таблицу и получить все в 1 куче.",  # noqa
            "python manage.py loaddata data.json": "Выгрузит в консоль содержимое БД из файла с данными.",  # noqa
            "python manage.py makemessages -l ru": "Создает русскую локализацию проекта. Предварительно нужно указать 'USE_L10N' и 'LOCALE_PATHS' в файле: 'settings.py'.",  # noqa
            "python manage.py compilemessages": "Компилирует сделанные локализации для использования в проекте.",  # noqa
            "python manage.py collectstatic": "Для продакшена собирает всю статику в 1 файл для работы. Для использования: {% static %}",  # noqa
        },  # Консольные команды для управления и работы с проектом.
        "url_formats": {  # Так же можно использовать 're_path' в Django для 're' функций поиска в URL. # noqa
            "<int:bla>": "Соответствует нулю или любому положительному целому числу. Возвращает int.",
            "<str:bla>": "Соответствует любой непустой строке, за исключением разделителя пути '/'. Это значение по умолчанию, если преобразователь не включен в выражение.",
            "<path:bla>": "Соответствует любой непустой строке, включая разделитель пути '/'. Например: '/my/site/bla'.",
            "<slug:bla>": "Соответствует любой короткой строке, состоящей из букв или цифр ASCII, а также символов дефиса и подчеркивания. Например: 'your-1st-site'.",
            "<uuid:bla>": """Соответствует отформатированному UUID. Чтобы предотвратить сопоставление нескольких URL-адресов с одной и той же 
                    страницей, необходимо включить дефисы, а буквы должны быть строчными. Например: '075194d3-6885-417e-a8a8-6c931e272f00'.""",
        },  # URL теги, поддерживаемые в Django. Типа <int:id> и все такое. # noqa
    }  # Информация по Django 4 версии. В проекте 'django_site' можно найти больше информации и примеров. # noqa
